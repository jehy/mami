{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 8954670b71fa2f188835","webpack:///./node_modules/console-browserify/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/util/util.js","webpack:///./src/js/index.js","webpack:///./node_modules/code-prettify/src/prettify.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/util/support/isBufferBrowser.js","webpack:///./node_modules/util/node_modules/inherits/inherits_browser.js","webpack:///./node_modules/assert/assert.js","webpack:///./node_modules/date-now/index.js","webpack:///./node_modules/code-prettify/src/run_prettify.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","log","info","console","apply","arguments","warn","error","time","label","times","now","timeEnd","Error","duration","trace","err","message","util","format","stack","dir","inspect","consoleAssert","expression","arr","slice","assert","ok","Array","window","functions","length","tuple","f","g","this","Function","eval","e","process","obj","opts","ctx","seen","stylize","stylizeNoColor","depth","colors","isBoolean","showHidden","_extend","isUndefined","customInspect","stylizeWithColor","formatValue","str","styleType","style","styles","arrayToHash","array","hash","forEach","val","idx","value","recurseTimes","isFunction","constructor","ret","isString","primitive","formatPrimitive","keys","visibleKeys","getOwnPropertyNames","isError","indexOf","formatError","isRegExp","RegExp","toString","isDate","Date","base","braces","isArray","toUTCString","push","output","formatArray","map","key","formatProperty","pop","reduceToSingleString","simple","JSON","stringify","replace","isNumber","isNull","String","match","desc","getOwnPropertyDescriptor","set","split","line","join","substr","numLinesEst","reduce","prev","cur","ar","arg","isNullOrUndefined","isSymbol","re","isObject","objectToString","isPrimitive","pad","timestamp","getHours","getMinutes","getSeconds","getDate","months","getMonth","prop","formatRegExp","objects","args","len","x","Number","_","deprecate","fn","msg","deprecated","warned","throwDeprecation","traceDeprecation","noDeprecation","debugEnviron","debugs","debuglog","env","NODE_DEBUG","toUpperCase","test","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","number","boolean","undefined","null","string","date","regexp","isBuffer","inherits","origin","add","prettyPrintOne","prettyPrint","combinePrefixPatterns","regexs","decodeEscape","charsetPart","cc0","charCodeAt","c1","charAt","escapeCharToCodeUnit","parseInt","substring","encodeEscape","charCode","ch","fromCharCode","caseFoldCharset","charSet","charsetParts","ranges","out","end","start","Math","max","min","sort","a","b","consolidatedRanges","lastRange","range","capturedGroupIndex","needToFoldCase","ignoreCase","regex","source","t","v","r","rewritten","multiline","parts","capturedGroups","groupIndex","decimalValue","ch0","cc","extractSourceSpans","node","isPreformatted","walk","type","nodeType","nocode","className","child","firstChild","nextSibling","nodeName","toLowerCase","chunks","k","spans","text","nodeValue","sourceCode","appendDecorations","sourceNode","basePos","langHandler","job","pre","langExtension","numberLines","decorations","childContentWrapper","element","wrapper","notWs","createSimpleLexer","shortcutStylePatterns","fallthroughStylePatterns","tokenizer","shortcuts","allPatterns","concat","allRegexs","regexKeys","patternParts","shortcutChars","nPatterns","decorate","PR_PLAIN","pos","tokens","styleCache","ti","nTokens","isEmbedded","token","PR_SOURCE","tokenStart","embeddedSource","embeddedSourceStart","embeddedSourceEnd","lang","langHandlerForExtension","sourceDecorator","options","PR_STRING","hc","PR_COMMENT","regexLiterals","regexExcls","regexAny","REGEX_LITERAL","REGEXP_PRECEDER_PATTERN","types","PR_TYPE","keywords","PR_KEYWORD","punctuation","PR_LITERAL","PR_PUNCTUATION","startLineNum","lineBreak","firstLine","index","tail","parent","parentNode","insertBefore","document","createTextNode","breakAfter","removeChild","lineEndNode","breakLeftOf","limit","copy","rightSide","cloneNode","parentClone","next","appendChild","sibling","copiedListItem","listItems","ownerDocument","li","createElement","setAttribute","ol","offset","recombineTagsAndDecorations","isIE8OrEarlier","exec","navigator","userAgent","newlineRe","sourceLength","sourceIndex","nSpans","spanIndex","nDecorations","decorationIndex","decPos","startPos","startDec","oldDisplay","display","styledText","spanEnd","decEnd","textNode","span","replaceChild","registerLangHandler","handler","fileExtensions","ext","langHandlerRegistry","win","extension","applyDecorator","opt_langExtension","sourceAndSpans","$prettyPrintOne","sourceCodeHtml","opt_numberLines","nl","container","innerHTML","$prettyPrint","opt_whenDone","opt_root","byTagName","tn","root","getElementsByTagName","doWork","endTime","clock","Infinity","elements","cs","attrs","EMPTY","preceder","previousSibling","nt","prettyPrintRe","prettyPrintedRe","nested","tagName","preCodeXmpRe","langExtensionRe","codeRe","preformatted","preformattedTagNameRe","currentStyle","defaultView","doc","whitespace","getComputedStyle","getPropertyValue","lineNums","setTimeout","body","codeSegments","j","FLOW_CONTROL_KEYWORDS","C_KEYWORDS","COMMON_KEYWORDS","CPP_KEYWORDS","JAVA_KEYWORDS","CSHARP_KEYWORDS","JSCRIPT_KEYWORDS","PERL_KEYWORDS","PYTHON_KEYWORDS","RUBY_KEYWORDS","SH_KEYWORDS","ALL_KEYWORDS","C_TYPES","decorateSource","hashComments","cStyleComments","multiLineStrings","verbatimStrings","tripleQuotedStrings","multilineStrings","PR","PR_ATTRIB_NAME","PR_ATTRIB_VALUE","PR_DECLARATION","PR_NOCODE","PR_TAG","define","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","run","Item","noop","nextTick","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","fill","readUInt8","create","ctor","superCtor","super_","writable","TempCtor","compare","y","Buffer","_isBuffer","pToString","isView","arrbuf","ArrayBuffer","DataView","buffer","getName","func","functionsHaveNames","truncate","something","rawname","getMessage","self","actual","operator","expected","fail","stackStartFunction","AssertionError","_deepEqual","strict","memos","getTime","lastIndex","Float32Array","Float64Array","Uint8Array","actualIndex","objEquiv","isArguments","actualVisitedObjects","getPrototypeOf","aIsArgs","bIsArgs","pSlice","ka","objectKeys","kb","notDeepStrictEqual","expectedException","isPrototypeOf","_tryBlock","block","_throws","shouldThrow","TypeError","userProvidedMessage","isUnwantedException","isUnexpectedException","hasOwn","generatedMessage","captureStackTrace","fn_name","next_line","equal","notEqual","deepEqual","deepStrictEqual","notDeepEqual","strictEqual","notStrictEqual","throws","doesNotThrow","ifError","contentLoaded","callback","addEventListener","done","top","rem","init","readyState","poll","doScroll","createEventObject","frameElement","checkPendingLanguages","pendingLanguages","onLangsLoaded","autorun","callbacks","documentElement","head","scriptQuery","scripts","script","src","langs","skins","decodeURIComponent","LOADER_BASE_URL","onload","onerror","onreadystatechange","encodeURIComponent","skinUrls","stylesheets","load","link","rel","href"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/*global window, global*/\nvar util = __webpack_require__(2)\nvar assert = __webpack_require__(11)\nvar now = __webpack_require__(12)\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof global !== \"undefined\" && global.console) {\n    console = global.console\n} else if (typeof window !== \"undefined\" && window.console) {\n    console = window.console\n} else {\n    console = {}\n}\n\nvar functions = [\n    [log, \"log\"],\n    [info, \"info\"],\n    [warn, \"warn\"],\n    [error, \"error\"],\n    [time, \"time\"],\n    [timeEnd, \"timeEnd\"],\n    [trace, \"trace\"],\n    [dir, \"dir\"],\n    [consoleAssert, \"assert\"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error(\"No such label: \" + label)\n    }\n\n    var duration = now() - time\n    console.log(label + \": \" + duration + \"ms\")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = \"Trace\"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + \"\\n\")\n}\n\nfunction consoleAssert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process, console) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(9);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(10);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(8), __webpack_require__(0)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(4);\n\n__webpack_require__(5);\n\n__webpack_require__(6);\n\n__webpack_require__(7);\n__webpack_require__(13);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(console) {/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n\n/**\n* @typedef {!Array.<number|string>}\n* Alternating indices and the decorations that should be inserted there.\n* The indices are monotonically increasing.\n*/\nvar DecorationsT;\n\n/**\n* @typedef {!{\n*   sourceNode: !Element,\n*   pre: !(number|boolean),\n*   langExtension: ?string,\n*   numberLines: ?(number|boolean),\n*   sourceCode: ?string,\n*   spans: ?(Array.<number|Node>),\n*   basePos: ?number,\n*   decorations: ?DecorationsT\n* }}\n* <dl>\n*  <dt>sourceNode<dd>the element containing the source\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>pre<dd>truthy if white-space in text nodes\n*     should be considered significant.\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n*  <dt>decorations<dd>an array of style classes preceded\n*     by the position at which they start in job.sourceCode in order\n*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n*     source.\n* </dl>\n*/\nvar JobT;\n\n/**\n* @typedef {!{\n*   sourceCode: string,\n*   spans: !(Array.<number|Node>)\n* }}\n* <dl>\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n* </dl>\n*/\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = false;\n\nvar HACK_TO_FIX_JS_INCLUDE_PL;\n\n/**\n * {@type !{\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * }}\n * @const\n */\nvar PR;\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n/**\n * Pretty print a chunk of code.\n * @param {string} sourceCodeHtml The HTML to pretty print.\n * @param {string} opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param {number|boolean} opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return {string} code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n * {@code class=prettyprint} and prettify them.\n *\n * @param {Function} opt_whenDone called when prettifying is done.\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to {@code document.body}.\n */\nvar prettyPrint;\n\n\n(function () {\n  var win = window;\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n      \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" +\n      \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" +\n      \"yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n  \n  \n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * <p>The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n  \n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n  \n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n  \n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n  \n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n  \n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    }\n  \n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n  \n      var out = ['['];\n      if (inverse) { out.push('^'); }\n  \n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          out.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n  \n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n  \n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n  \n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n  \n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n  \n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue) {\n            if (decimalValue <= groupIndex) {\n              capturedGroups[decimalValue] = -1;\n            } else {\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            }\n          }\n        }\n      }\n  \n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          }\n        }\n      }\n  \n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n  \n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n  \n      return parts.join('');\n    }\n  \n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n  \n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @param {boolean|number} isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return {SourceSpansT} source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n  \n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n  \n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1) {  // Element\n        if (nocode.test(node.className)) { return; }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) {\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        }\n      } else if (type == 3 || type == 4) {  // Text\n        var text = node.nodeValue;\n        if (text.length) {\n          if (!isPreformatted) {\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          } else {\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          }\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        }\n      }\n    }\n  \n    walk(node);\n  \n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {!Element} sourceNode\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param {string} sourceCode\n   * @param {function(JobT)} langHandler\n   * @param {DecorationsT} out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    /** @type {JobT} */\n    var job = {\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo {#}\n      // {#}\n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n  \n    var document = node.ownerDocument;\n  \n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n  \n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n  \n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n  \n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n  \n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n  \n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n  \n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n  \n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n  \n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n  \n    node.appendChild(ol);\n  }\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n  \n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n  \n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n  \n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n  \n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n  \n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n  \n    nDecorations = decorations.length = decPos;\n  \n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n  \n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n  \n        var end = Math.min(spanEnd, decEnd);\n  \n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n  \n        sourceIndex = end;\n  \n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint': prettyPrint =\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(2);\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nmodule.exports = now\n\nfunction now() {\n    return new Date().getTime()\n}\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(console) {/**\n * @license\n * Copyright (C) 2013 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * <div style=\"white-space: pre\">\n * Looks at query parameters to decide which language handlers and style-sheets\n * to load.\n *\n * Query Parameter     Format           Effect                        Default\n * +------------------+---------------+------------------------------+--------+\n * | autorun=         | true | false  | If true then prettyPrint()   | \"true\" |\n * |                  |               | is called on page load.      |        |\n * +------------------+---------------+------------------------------+--------+\n * | lang=            | language name | Loads the language handler   | Can    |\n * |                  |               | named \"lang-<NAME>.js\".      | appear |\n * |                  |               | See available handlers at    | many   |\n * |                  |               | https://github.com/google/   | times. |\n * |                  |               | code-prettify/tree/master/   |        |\n * |                  |               | src                          |        |\n * +------------------+---------------+------------------------------+--------+\n * | skin=            | skin name     | Loads the skin stylesheet    | none.  |\n * |                  |               | named \"<NAME>.css\".          |        |\n * |                  |               | https://cdn.rawgit.com/      |        |\n * |                  |               | google/code-prettify/master/ |        |\n * |                  |               | styles/index.html            |        |\n * +------------------+---------------+------------------------------+--------+\n * | callback=        | JS identifier | When \"prettyPrint\" finishes  | none   |\n * |                  |               | window.exports[js_ident] is  |        |\n * |                  |               | called.                      |        |\n * |                  |               | The callback must be under   |        |\n * |                  |               | exports to reduce the risk   |        |\n * |                  |               | of XSS via query parameter   |        |\n * |                  |               | injection.                   |        |\n * +------------------+---------------+------------------------------+--------+\n *\n * Exmaples\n * .../run_prettify.js?lang=css&skin=sunburst\n *   1. Loads the CSS language handler which can be used to prettify CSS\n *      stylesheets, HTML <style> element bodies and style=\"...\" attributes\n *      values.\n *   2. Loads the sunburst.css stylesheet instead of the default prettify.css\n *      stylesheet.\n *      A gallery of stylesheets is available at\n *      https://cdn.rawgit.com/google/code-prettify/master/styles/index.html\n *   3. Since autorun=false is not specified, calls prettyPrint() on page load.\n * </div>\n */\n\n/**\n* @typedef {!Array.<number|string>}\n* Alternating indices and the decorations that should be inserted there.\n* The indices are monotonically increasing.\n*/\nvar DecorationsT;\n\n/**\n* @typedef {!{\n*   sourceNode: !Element,\n*   pre: !(number|boolean),\n*   langExtension: ?string,\n*   numberLines: ?(number|boolean),\n*   sourceCode: ?string,\n*   spans: ?(Array.<number|Node>),\n*   basePos: ?number,\n*   decorations: ?DecorationsT\n* }}\n* <dl>\n*  <dt>sourceNode<dd>the element containing the source\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>pre<dd>truthy if white-space in text nodes\n*     should be considered significant.\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n*  <dt>decorations<dd>an array of style classes preceded\n*     by the position at which they start in job.sourceCode in order\n*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n*     source.\n* </dl>\n*/\nvar JobT;\n\n/**\n* @typedef {!{\n*   sourceCode: string,\n*   spans: !(Array.<number|Node>)\n* }}\n* <dl>\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n* </dl>\n*/\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = false;\n\n(function () {\n  \"use strict\";\n\n  var win = window;\n  var doc = document;\n  var root = doc.documentElement;\n  var head = doc['head'] || doc.getElementsByTagName(\"head\")[0] || root;\n\n  // From http://javascript.nwbox.com/ContentLoaded/contentloaded.js\n  // Author: Diego Perini (diego.perini at gmail.com)\n  // Summary: cross-browser wrapper for DOMContentLoaded\n  // Updated: 20101020\n  // License: MIT\n  // Version: 1.2\n  function contentLoaded(callback) {\n    var addEventListener = doc['addEventListener'];\n    var done = false, top = true,\n        add = addEventListener ? 'addEventListener' : 'attachEvent',\n        rem = addEventListener ? 'removeEventListener' : 'detachEvent',\n        pre = addEventListener ? '' : 'on',\n\n        init = function(e) {\n          if (e.type == 'readystatechange' && doc.readyState != 'complete') {\n            return;\n          }\n          (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);\n          if (!done && (done = true)) { callback.call(win, e.type || e); }\n        },\n\n        poll = function() {\n          try {\n            root.doScroll('left');\n          } catch(e) {\n            win.setTimeout(poll, 50);\n            return;\n          }\n          init('poll');\n        };\n\n    if (doc.readyState == 'complete') {\n      callback.call(win, 'lazy');\n    } else {\n      if (doc.createEventObject && root.doScroll) {\n        try { top = !win.frameElement; } catch(e) { }\n        if (top) { poll(); }\n      }\n      doc[add](pre + 'DOMContentLoaded', init, false);\n      doc[add](pre + 'readystatechange', init, false);\n      win[add](pre + 'load', init, false);\n    }\n  }\n\n  // Given a list of URLs to stylesheets, loads the first that loads without\n  // triggering an error event.\n  function loadStylesheetsFallingBack(stylesheets) {\n    var n = stylesheets.length;\n    function load(i) {\n      if (i === n) { return; }\n      var link = doc.createElement('link');\n      link.rel = 'stylesheet';\n      link.type = 'text/css';\n      if (i + 1 < n) {\n        // http://pieisgood.org/test/script-link-events/ indicates that many\n        // versions of IE do not support onerror on <link>s, though\n        // http://msdn.microsoft.com/en-us/library/ie/ms535848(v=vs.85).aspx\n        // indicates that recent IEs do support error.\n        link.error = link.onerror = function () { load(i + 1); };\n      }\n      link.href = stylesheets[i];\n      head.appendChild(link);\n    }\n    load(0);\n  }\n\n  var scriptQuery = '';\n  // Look for the <script> node that loads this script to get its parameters.\n  // This starts looking at the end instead of just considering the last\n  // because deferred and async scripts run out of order.\n  // If the script is loaded twice, then this will run in reverse order.\n  var scripts = doc.getElementsByTagName('script');\n  for (var i = scripts.length; --i >= 0;) {\n    var script = scripts[i];\n    var match = script.src.match(\n        /^[^?#]*\\/run_prettify\\.js(\\?[^#]*)?(?:#.*)?$/);\n    if (match) {\n      scriptQuery = match[1] || '';\n      // Remove the script from the DOM so that multiple runs at least run\n      // multiple times even if parameter sets are interpreted in reverse\n      // order.\n      script.parentNode.removeChild(script);\n      break;\n    }\n  }\n\n  // Pull parameters into local variables.\n  var autorun = true;\n  var langs = [];\n  var skins = [];\n  var callbacks = [];\n  scriptQuery.replace(\n      /[?&]([^&=]+)=([^&]+)/g,\n      function (_, name, value) {\n        value = decodeURIComponent(value);\n        name = decodeURIComponent(name);\n        if (name == 'autorun')   { autorun = !/^[0fn]/i.test(value); } else\n        if (name == 'lang')      { langs.push(value);                } else\n        if (name == 'skin')      { skins.push(value);                } else\n        if (name == 'callback')  { callbacks.push(value);            }\n      });\n\n  // Use https to avoid mixed content warnings in client pages and to\n  // prevent a MITM from rewrite prettify mid-flight.\n  // This only works if this script is loaded via https : something\n  // over which we exercise no control.\n  var LOADER_BASE_URL =\n     'https://cdn.rawgit.com/google/code-prettify/master/loader';\n\n  for (var i = 0, n = langs.length; i < n; ++i) (function (lang) {\n    var script = doc.createElement(\"script\");\n\n    // Excerpted from jQuery.ajaxTransport(\"script\") to fire events when\n    // a script is finished loading.\n    // Attach handlers for each script\n    script.onload = script.onerror = script.onreadystatechange = function () {\n      if (script && (\n            !script.readyState || /loaded|complete/.test(script.readyState))) {\n        // Handle memory leak in IE\n        script.onerror = script.onload = script.onreadystatechange = null;\n\n        --pendingLanguages;\n        checkPendingLanguages();\n\n        // Remove the script\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n\n        script = null;\n      }\n    };\n\n    script.type = 'text/javascript';\n    script.src = LOADER_BASE_URL\n      + '/lang-' + encodeURIComponent(langs[i]) + '.js';\n\n    // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n    head.insertBefore(script, head.firstChild);\n  })(langs[i]);\n\n  var pendingLanguages = langs.length;\n  function checkPendingLanguages() {\n    if (!pendingLanguages) {\n      win.setTimeout(onLangsLoaded, 0);\n    }\n  }\n\n  var skinUrls = [];\n  for (var i = 0, n = skins.length; i < n; ++i) {\n    skinUrls.push(LOADER_BASE_URL\n        + '/skins/' + encodeURIComponent(skins[i]) + '.css');\n  }\n  skinUrls.push(LOADER_BASE_URL + '/prettify.css');\n  loadStylesheetsFallingBack(skinUrls);\n\n  var prettyPrint = (function () {\n    /**\n     * @license\n     * Copyright (C) 2006 Google Inc.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    \n    /**\n     * @fileoverview\n     * some functions for browser-side pretty printing of code contained in html.\n     *\n     * <p>\n     * For a fairly comprehensive set of languages see the\n     * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n     * file that came with this source.  At a minimum, the lexer should work on a\n     * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n     * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n     * and a subset of Perl, but, because of commenting conventions, doesn't work on\n     * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n     * <p>\n     * Usage: <ol>\n     * <li> include this source file in an html page via\n     *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n     * <li> define style rules.  See the example page for examples.\n     * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n     *    {@code class=prettyprint.}\n     *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n     *    printer needs to do more substantial DOM manipulations to support that, so\n     *    some css styles may not be preserved.\n     * </ol>\n     * That's it.  I wanted to keep the API as simple as possible, so there's no\n     * need to specify which language the code is in, but if you wish, you can add\n     * another class to the {@code <pre>} or {@code <code>} element to specify the\n     * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n     * starts with \"lang-\" followed by a file extension, specifies the file type.\n     * See the \"lang-*.js\" files in this directory for code that implements\n     * per-language file handlers.\n     * <p>\n     * Change log:<br>\n     * cbeust, 2006/08/22\n     * <blockquote>\n     *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n     * </blockquote>\n     * @requires console\n     */\n    \n    // JSLint declarations\n    /*global console, document, navigator, setTimeout, window, define */\n    \n    \n    var HACK_TO_FIX_JS_INCLUDE_PL;\n    \n    /**\n     * {@type !{\n     *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n     *   'registerLangHandler': function (function (JobT), Array.<string>),\n     *   'PR_ATTRIB_NAME': string,\n     *   'PR_ATTRIB_NAME': string,\n     *   'PR_ATTRIB_VALUE': string,\n     *   'PR_COMMENT': string,\n     *   'PR_DECLARATION': string,\n     *   'PR_KEYWORD': string,\n     *   'PR_LITERAL': string,\n     *   'PR_NOCODE': string,\n     *   'PR_PLAIN': string,\n     *   'PR_PUNCTUATION': string,\n     *   'PR_SOURCE': string,\n     *   'PR_STRING': string,\n     *   'PR_TAG': string,\n     *   'PR_TYPE': string,\n     *   'prettyPrintOne': function (string, string, number|boolean),\n     *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n     * }}\n     * @const\n     */\n    var PR;\n    \n    /**\n     * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n     * UI events.\n     * If set to {@code false}, {@code prettyPrint()} is synchronous.\n     */\n    window['PR_SHOULD_USE_CONTINUATION'] = true;\n    \n    /**\n     * Pretty print a chunk of code.\n     * @param {string} sourceCodeHtml The HTML to pretty print.\n     * @param {string} opt_langExtension The language name to use.\n     *     Typically, a filename extension like 'cpp' or 'java'.\n     * @param {number|boolean} opt_numberLines True to number lines,\n     *     or the 1-indexed number of the first line in sourceCodeHtml.\n     * @return {string} code as html, but prettier\n     */\n    var prettyPrintOne;\n    /**\n     * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n     * {@code class=prettyprint} and prettify them.\n     *\n     * @param {Function} opt_whenDone called when prettifying is done.\n     * @param {HTMLElement|HTMLDocument} opt_root an element or document\n     *   containing all the elements to pretty print.\n     *   Defaults to {@code document.body}.\n     */\n    var prettyPrint;\n    \n    \n    (function () {\n      var win = window;\n      // Keyword lists for various languages.\n      // We use things that coerce to strings to make them compact when minified\n      // and to defeat aggressive optimizers that fold large string constants.\n      var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n      var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n          \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n          \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n      var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n          \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n      var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n          \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n          \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n          \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n          \"static_cast,template,typeid,typename,using,virtual,where\"];\n      var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n          \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n          \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n          \"throws,transient\"];\n      var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n          \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n          \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n          \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n          \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n          \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n      var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n          \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n          \"throw,true,try,unless,until,when,while,yes\";\n      var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n          \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" +\n          \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" +\n          \"yield,Infinity,NaN\"];\n      var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n          \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n          \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n      var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n          \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n          \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n          \"False,True,None\"];\n      var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n          \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n          \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n          \"BEGIN,END\"];\n      var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n          \"function,in,local,set,then,until\"];\n      var ALL_KEYWORDS = [\n          CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n          PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n      var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n    \n      // token style names.  correspond to css classes\n      /**\n       * token style for a string literal\n       * @const\n       */\n      var PR_STRING = 'str';\n      /**\n       * token style for a keyword\n       * @const\n       */\n      var PR_KEYWORD = 'kwd';\n      /**\n       * token style for a comment\n       * @const\n       */\n      var PR_COMMENT = 'com';\n      /**\n       * token style for a type\n       * @const\n       */\n      var PR_TYPE = 'typ';\n      /**\n       * token style for a literal value.  e.g. 1, null, true.\n       * @const\n       */\n      var PR_LITERAL = 'lit';\n      /**\n       * token style for a punctuation string.\n       * @const\n       */\n      var PR_PUNCTUATION = 'pun';\n      /**\n       * token style for plain text.\n       * @const\n       */\n      var PR_PLAIN = 'pln';\n    \n      /**\n       * token style for an sgml tag.\n       * @const\n       */\n      var PR_TAG = 'tag';\n      /**\n       * token style for a markup declaration such as a DOCTYPE.\n       * @const\n       */\n      var PR_DECLARATION = 'dec';\n      /**\n       * token style for embedded source.\n       * @const\n       */\n      var PR_SOURCE = 'src';\n      /**\n       * token style for an sgml attribute name.\n       * @const\n       */\n      var PR_ATTRIB_NAME = 'atn';\n      /**\n       * token style for an sgml attribute value.\n       * @const\n       */\n      var PR_ATTRIB_VALUE = 'atv';\n    \n      /**\n       * A class that indicates a section of markup that is not code, e.g. to allow\n       * embedding of line numbers within code listings.\n       * @const\n       */\n      var PR_NOCODE = 'nocode';\n    \n      \n      \n      /**\n       * A set of tokens that can precede a regular expression literal in\n       * javascript\n       * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n       * has the full list, but I've removed ones that might be problematic when\n       * seen in languages that don't support regular expression literals.\n       *\n       * <p>Specifically, I've removed any keywords that can't precede a regexp\n       * literal in a syntactically legal javascript program, and I've removed the\n       * \"in\" keyword since it's not a keyword in many languages, and might be used\n       * as a count of inches.\n       *\n       * <p>The link above does not accurately describe EcmaScript rules since\n       * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n       * very well in practice.\n       *\n       * @private\n       * @const\n       */\n      var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n      \n      // CAVEAT: this does not properly handle the case where a regular\n      // expression immediately follows another since a regular expression may\n      // have flags for case-sensitivity and the like.  Having regexp tokens\n      // adjacent is not valid in any language I'm aware of, so I'm punting.\n      // TODO: maybe style special characters inside a regexp as punctuation.\n    \n      /**\n       * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n       * matches the union of the sets of strings matched by the input RegExp.\n       * Since it matches globally, if the input strings have a start-of-input\n       * anchor (/^.../), it is ignored for the purposes of unioning.\n       * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n       * @return {RegExp} a global regex.\n       */\n      function combinePrefixPatterns(regexs) {\n        var capturedGroupIndex = 0;\n      \n        var needToFoldCase = false;\n        var ignoreCase = false;\n        for (var i = 0, n = regexs.length; i < n; ++i) {\n          var regex = regexs[i];\n          if (regex.ignoreCase) {\n            ignoreCase = true;\n          } else if (/[a-z]/i.test(regex.source.replace(\n                         /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n            needToFoldCase = true;\n            ignoreCase = false;\n            break;\n          }\n        }\n      \n        var escapeCharToCodeUnit = {\n          'b': 8,\n          't': 9,\n          'n': 0xa,\n          'v': 0xb,\n          'f': 0xc,\n          'r': 0xd\n        };\n      \n        function decodeEscape(charsetPart) {\n          var cc0 = charsetPart.charCodeAt(0);\n          if (cc0 !== 92 /* \\\\ */) {\n            return cc0;\n          }\n          var c1 = charsetPart.charAt(1);\n          cc0 = escapeCharToCodeUnit[c1];\n          if (cc0) {\n            return cc0;\n          } else if ('0' <= c1 && c1 <= '7') {\n            return parseInt(charsetPart.substring(1), 8);\n          } else if (c1 === 'u' || c1 === 'x') {\n            return parseInt(charsetPart.substring(2), 16);\n          } else {\n            return charsetPart.charCodeAt(1);\n          }\n        }\n      \n        function encodeEscape(charCode) {\n          if (charCode < 0x20) {\n            return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n          }\n          var ch = String.fromCharCode(charCode);\n          return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n              ? \"\\\\\" + ch : ch;\n        }\n      \n        function caseFoldCharset(charSet) {\n          var charsetParts = charSet.substring(1, charSet.length - 1).match(\n              new RegExp(\n                  '\\\\\\\\u[0-9A-Fa-f]{4}'\n                  + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n                  + '|\\\\\\\\[0-3][0-7]{0,2}'\n                  + '|\\\\\\\\[0-7]{1,2}'\n                  + '|\\\\\\\\[\\\\s\\\\S]'\n                  + '|-'\n                  + '|[^-\\\\\\\\]',\n                  'g'));\n          var ranges = [];\n          var inverse = charsetParts[0] === '^';\n      \n          var out = ['['];\n          if (inverse) { out.push('^'); }\n      \n          for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n            var p = charsetParts[i];\n            if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n              out.push(p);\n            } else {\n              var start = decodeEscape(p);\n              var end;\n              if (i + 2 < n && '-' === charsetParts[i + 1]) {\n                end = decodeEscape(charsetParts[i + 2]);\n                i += 2;\n              } else {\n                end = start;\n              }\n              ranges.push([start, end]);\n              // If the range might intersect letters, then expand it.\n              // This case handling is too simplistic.\n              // It does not deal with non-latin case folding.\n              // It works for latin source code identifiers though.\n              if (!(end < 65 || start > 122)) {\n                if (!(end < 65 || start > 90)) {\n                  ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n                }\n                if (!(end < 97 || start > 122)) {\n                  ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n                }\n              }\n            }\n          }\n      \n          // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n          // -> [[1, 12], [14, 14], [16, 17]]\n          ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n          var consolidatedRanges = [];\n          var lastRange = [];\n          for (var i = 0; i < ranges.length; ++i) {\n            var range = ranges[i];\n            if (range[0] <= lastRange[1] + 1) {\n              lastRange[1] = Math.max(lastRange[1], range[1]);\n            } else {\n              consolidatedRanges.push(lastRange = range);\n            }\n          }\n      \n          for (var i = 0; i < consolidatedRanges.length; ++i) {\n            var range = consolidatedRanges[i];\n            out.push(encodeEscape(range[0]));\n            if (range[1] > range[0]) {\n              if (range[1] + 1 > range[0]) { out.push('-'); }\n              out.push(encodeEscape(range[1]));\n            }\n          }\n          out.push(']');\n          return out.join('');\n        }\n      \n        function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n          // Split into character sets, escape sequences, punctuation strings\n          // like ('(', '(?:', ')', '^'), and runs of characters that do not\n          // include any of the above.\n          var parts = regex.source.match(\n              new RegExp(\n                  '(?:'\n                  + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n                  + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n                  + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n                  + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n                  + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n                  + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n                  + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n                  + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n                  + ')',\n                  'g'));\n          var n = parts.length;\n      \n          // Maps captured group numbers to the number they will occupy in\n          // the output or to -1 if that has not been determined, or to\n          // undefined if they need not be capturing in the output.\n          var capturedGroups = [];\n      \n          // Walk over and identify back references to build the capturedGroups\n          // mapping.\n          for (var i = 0, groupIndex = 0; i < n; ++i) {\n            var p = parts[i];\n            if (p === '(') {\n              // groups are 1-indexed, so max group index is count of '('\n              ++groupIndex;\n            } else if ('\\\\' === p.charAt(0)) {\n              var decimalValue = +p.substring(1);\n              if (decimalValue) {\n                if (decimalValue <= groupIndex) {\n                  capturedGroups[decimalValue] = -1;\n                } else {\n                  // Replace with an unambiguous escape sequence so that\n                  // an octal escape sequence does not turn into a backreference\n                  // to a capturing group from an earlier regex.\n                  parts[i] = encodeEscape(decimalValue);\n                }\n              }\n            }\n          }\n      \n          // Renumber groups and reduce capturing groups to non-capturing groups\n          // where possible.\n          for (var i = 1; i < capturedGroups.length; ++i) {\n            if (-1 === capturedGroups[i]) {\n              capturedGroups[i] = ++capturedGroupIndex;\n            }\n          }\n          for (var i = 0, groupIndex = 0; i < n; ++i) {\n            var p = parts[i];\n            if (p === '(') {\n              ++groupIndex;\n              if (!capturedGroups[groupIndex]) {\n                parts[i] = '(?:';\n              }\n            } else if ('\\\\' === p.charAt(0)) {\n              var decimalValue = +p.substring(1);\n              if (decimalValue && decimalValue <= groupIndex) {\n                parts[i] = '\\\\' + capturedGroups[decimalValue];\n              }\n            }\n          }\n      \n          // Remove any prefix anchors so that the output will match anywhere.\n          // ^^ really does mean an anchored match though.\n          for (var i = 0; i < n; ++i) {\n            if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n          }\n      \n          // Expand letters to groups to handle mixing of case-sensitive and\n          // case-insensitive patterns if necessary.\n          if (regex.ignoreCase && needToFoldCase) {\n            for (var i = 0; i < n; ++i) {\n              var p = parts[i];\n              var ch0 = p.charAt(0);\n              if (p.length >= 2 && ch0 === '[') {\n                parts[i] = caseFoldCharset(p);\n              } else if (ch0 !== '\\\\') {\n                // TODO: handle letters in numeric escapes.\n                parts[i] = p.replace(\n                    /[a-zA-Z]/g,\n                    function (ch) {\n                      var cc = ch.charCodeAt(0);\n                      return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                    });\n              }\n            }\n          }\n      \n          return parts.join('');\n        }\n      \n        var rewritten = [];\n        for (var i = 0, n = regexs.length; i < n; ++i) {\n          var regex = regexs[i];\n          if (regex.global || regex.multiline) { throw new Error('' + regex); }\n          rewritten.push(\n              '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n        }\n      \n        return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n      }\n    \n      /**\n       * Split markup into a string of source code and an array mapping ranges in\n       * that string to the text nodes in which they appear.\n       *\n       * <p>\n       * The HTML DOM structure:</p>\n       * <pre>\n       * (Element   \"p\"\n       *   (Element \"b\"\n       *     (Text  \"print \"))       ; #1\n       *   (Text    \"'Hello '\")      ; #2\n       *   (Element \"br\")            ; #3\n       *   (Text    \"  + 'World';\")) ; #4\n       * </pre>\n       * <p>\n       * corresponds to the HTML\n       * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n       *\n       * <p>\n       * It will produce the output:</p>\n       * <pre>\n       * {\n       *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n       *   //                     1          2\n       *   //           012345678901234 5678901234567\n       *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n       * }\n       * </pre>\n       * <p>\n       * where #1 is a reference to the {@code \"print \"} text node above, and so\n       * on for the other text nodes.\n       * </p>\n       *\n       * <p>\n       * The {@code} spans array is an array of pairs.  Even elements are the start\n       * indices of substrings, and odd elements are the text nodes (or BR elements)\n       * that contain the text for those substrings.\n       * Substrings continue until the next index or the end of the source.\n       * </p>\n       *\n       * @param {Node} node an HTML DOM subtree containing source-code.\n       * @param {boolean|number} isPreformatted truthy if white-space in\n       *    text nodes should be considered significant.\n       * @return {SourceSpansT} source code and the nodes in which they occur.\n       */\n      function extractSourceSpans(node, isPreformatted) {\n        var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n      \n        var chunks = [];\n        var length = 0;\n        var spans = [];\n        var k = 0;\n      \n        function walk(node) {\n          var type = node.nodeType;\n          if (type == 1) {  // Element\n            if (nocode.test(node.className)) { return; }\n            for (var child = node.firstChild; child; child = child.nextSibling) {\n              walk(child);\n            }\n            var nodeName = node.nodeName.toLowerCase();\n            if ('br' === nodeName || 'li' === nodeName) {\n              chunks[k] = '\\n';\n              spans[k << 1] = length++;\n              spans[(k++ << 1) | 1] = node;\n            }\n          } else if (type == 3 || type == 4) {  // Text\n            var text = node.nodeValue;\n            if (text.length) {\n              if (!isPreformatted) {\n                text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n              } else {\n                text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n              }\n              // TODO: handle tabs here?\n              chunks[k] = text;\n              spans[k << 1] = length;\n              length += text.length;\n              spans[(k++ << 1) | 1] = node;\n            }\n          }\n        }\n      \n        walk(node);\n      \n        return {\n          sourceCode: chunks.join('').replace(/\\n$/, ''),\n          spans: spans\n        };\n      }\n    \n      /**\n       * Apply the given language handler to sourceCode and add the resulting\n       * decorations to out.\n       * @param {!Element} sourceNode\n       * @param {number} basePos the index of sourceCode within the chunk of source\n       *    whose decorations are already present on out.\n       * @param {string} sourceCode\n       * @param {function(JobT)} langHandler\n       * @param {DecorationsT} out\n       */\n      function appendDecorations(\n          sourceNode, basePos, sourceCode, langHandler, out) {\n        if (!sourceCode) { return; }\n        /** @type {JobT} */\n        var job = {\n          sourceNode: sourceNode,\n          pre: 1,\n          langExtension: null,\n          numberLines: null,\n          sourceCode: sourceCode,\n          spans: null,\n          basePos: basePos,\n          decorations: null\n        };\n        langHandler(job);\n        out.push.apply(out, job.decorations);\n      }\n    \n      var notWs = /\\S/;\n    \n      /**\n       * Given an element, if it contains only one child element and any text nodes\n       * it contains contain only space characters, return the sole child element.\n       * Otherwise returns undefined.\n       * <p>\n       * This is meant to return the CODE element in {@code <pre><code ...>} when\n       * there is a single child element that contains all the non-space textual\n       * content, but not to return anything where there are multiple child elements\n       * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n       * is textual content.\n       */\n      function childContentWrapper(element) {\n        var wrapper = undefined;\n        for (var c = element.firstChild; c; c = c.nextSibling) {\n          var type = c.nodeType;\n          wrapper = (type === 1)  // Element Node\n              ? (wrapper ? element : c)\n              : (type === 3)  // Text Node\n              ? (notWs.test(c.nodeValue) ? element : wrapper)\n              : wrapper;\n        }\n        return wrapper === element ? undefined : wrapper;\n      }\n    \n      /** Given triples of [style, pattern, context] returns a lexing function,\n        * The lexing function interprets the patterns to find token boundaries and\n        * returns a decoration list of the form\n        * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n        * where index_n is an index into the sourceCode, and style_n is a style\n        * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n        * all characters in sourceCode[index_n-1:index_n].\n        *\n        * The stylePatterns is a list whose elements have the form\n        * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n        *\n        * Style is a style constant like PR_PLAIN, or can be a string of the\n        * form 'lang-FOO', where FOO is a language extension describing the\n        * language of the portion of the token in $1 after pattern executes.\n        * E.g., if style is 'lang-lisp', and group 1 contains the text\n        * '(hello (world))', then that portion of the token will be passed to the\n        * registered lisp handler for formatting.\n        * The text before and after group 1 will be restyled using this decorator\n        * so decorators should take care that this doesn't result in infinite\n        * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n        * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n        * '<script>foo()<\\/script>', which would cause the current decorator to\n        * be called with '<script>' which would not match the same rule since\n        * group 1 must not be empty, so it would be instead styled as PR_TAG by\n        * the generic tag rule.  The handler registered for the 'js' extension would\n        * then be called with 'foo()', and finally, the current decorator would\n        * be called with '<\\/script>' which would not match the original rule and\n        * so the generic tag rule would identify it as a tag.\n        *\n        * Pattern must only match prefixes, and if it matches a prefix, then that\n        * match is considered a token with the same style.\n        *\n        * Context is applied to the last non-whitespace, non-comment token\n        * recognized.\n        *\n        * Shortcut is an optional string of characters, any of which, if the first\n        * character, gurantee that this pattern and only this pattern matches.\n        *\n        * @param {Array} shortcutStylePatterns patterns that always start with\n        *   a known character.  Must have a shortcut string.\n        * @param {Array} fallthroughStylePatterns patterns that will be tried in\n        *   order if the shortcut ones fail.  May have shortcuts.\n        *\n        * @return {function (JobT)} a function that takes an undecorated job and\n        *   attaches a list of decorations.\n        */\n      function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n        var shortcuts = {};\n        var tokenizer;\n        (function () {\n          var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n          var allRegexs = [];\n          var regexKeys = {};\n          for (var i = 0, n = allPatterns.length; i < n; ++i) {\n            var patternParts = allPatterns[i];\n            var shortcutChars = patternParts[3];\n            if (shortcutChars) {\n              for (var c = shortcutChars.length; --c >= 0;) {\n                shortcuts[shortcutChars.charAt(c)] = patternParts;\n              }\n            }\n            var regex = patternParts[1];\n            var k = '' + regex;\n            if (!regexKeys.hasOwnProperty(k)) {\n              allRegexs.push(regex);\n              regexKeys[k] = null;\n            }\n          }\n          allRegexs.push(/[\\0-\\uffff]/);\n          tokenizer = combinePrefixPatterns(allRegexs);\n        })();\n    \n        var nPatterns = fallthroughStylePatterns.length;\n    \n        /**\n         * Lexes job.sourceCode and attaches an output array job.decorations of\n         * style classes preceded by the position at which they start in\n         * job.sourceCode in order.\n         *\n         * @type{function (JobT)}\n         */\n        var decorate = function (job) {\n          var sourceCode = job.sourceCode, basePos = job.basePos;\n          var sourceNode = job.sourceNode;\n          /** Even entries are positions in source in ascending order.  Odd enties\n            * are style markers (e.g., PR_COMMENT) that run from that position until\n            * the end.\n            * @type {DecorationsT}\n            */\n          var decorations = [basePos, PR_PLAIN];\n          var pos = 0;  // index into sourceCode\n          var tokens = sourceCode.match(tokenizer) || [];\n          var styleCache = {};\n    \n          for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n            var token = tokens[ti];\n            var style = styleCache[token];\n            var match = void 0;\n    \n            var isEmbedded;\n            if (typeof style === 'string') {\n              isEmbedded = false;\n            } else {\n              var patternParts = shortcuts[token.charAt(0)];\n              if (patternParts) {\n                match = token.match(patternParts[1]);\n                style = patternParts[0];\n              } else {\n                for (var i = 0; i < nPatterns; ++i) {\n                  patternParts = fallthroughStylePatterns[i];\n                  match = token.match(patternParts[1]);\n                  if (match) {\n                    style = patternParts[0];\n                    break;\n                  }\n                }\n    \n                if (!match) {  // make sure that we make progress\n                  style = PR_PLAIN;\n                }\n              }\n    \n              isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n              if (isEmbedded && !(match && typeof match[1] === 'string')) {\n                isEmbedded = false;\n                style = PR_SOURCE;\n              }\n    \n              if (!isEmbedded) { styleCache[token] = style; }\n            }\n    \n            var tokenStart = pos;\n            pos += token.length;\n    \n            if (!isEmbedded) {\n              decorations.push(basePos + tokenStart, style);\n            } else {  // Treat group 1 as an embedded block of source code.\n              var embeddedSource = match[1];\n              var embeddedSourceStart = token.indexOf(embeddedSource);\n              var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n              if (match[2]) {\n                // If embeddedSource can be blank, then it would match at the\n                // beginning which would cause us to infinitely recurse on the\n                // entire token, so we catch the right context in match[2].\n                embeddedSourceEnd = token.length - match[2].length;\n                embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n              }\n              var lang = style.substring(5);\n              // Decorate the left of the embedded source\n              appendDecorations(\n                  sourceNode,\n                  basePos + tokenStart,\n                  token.substring(0, embeddedSourceStart),\n                  decorate, decorations);\n              // Decorate the embedded source\n              appendDecorations(\n                  sourceNode,\n                  basePos + tokenStart + embeddedSourceStart,\n                  embeddedSource,\n                  langHandlerForExtension(lang, embeddedSource),\n                  decorations);\n              // Decorate the right of the embedded section\n              appendDecorations(\n                  sourceNode,\n                  basePos + tokenStart + embeddedSourceEnd,\n                  token.substring(embeddedSourceEnd),\n                  decorate, decorations);\n            }\n          }\n          job.decorations = decorations;\n        };\n        return decorate;\n      }\n    \n      /** returns a function that produces a list of decorations from source text.\n        *\n        * This code treats \", ', and ` as string delimiters, and \\ as a string\n        * escape.  It does not recognize perl's qq() style strings.\n        * It has no special handling for double delimiter escapes as in basic, or\n        * the tripled delimiters used in python, but should work on those regardless\n        * although in those cases a single string literal may be broken up into\n        * multiple adjacent string literals.\n        *\n        * It recognizes C, C++, and shell style comments.\n        *\n        * @param {Object} options a set of optional parameters.\n        * @return {function (JobT)} a function that examines the source code\n        *     in the input job and builds a decoration list which it attaches to\n        *     the job.\n        */\n      function sourceDecorator(options) {\n        var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n        if (options['tripleQuotedStrings']) {\n          // '''multi-line-string''', 'single-line-string', and double-quoted\n          shortcutStylePatterns.push(\n              [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n               null, '\\'\"']);\n        } else if (options['multiLineStrings']) {\n          // 'multi-line-string', \"multi-line-string\"\n          shortcutStylePatterns.push(\n              [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n               null, '\\'\"`']);\n        } else {\n          // 'single-line-string', \"single-line-string\"\n          shortcutStylePatterns.push(\n              [PR_STRING,\n               /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n               null, '\"\\'']);\n        }\n        if (options['verbatimStrings']) {\n          // verbatim-string-literal production from the C# grammar.  See issue 93.\n          fallthroughStylePatterns.push(\n              [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n        }\n        var hc = options['hashComments'];\n        if (hc) {\n          if (options['cStyleComments']) {\n            if (hc > 1) {  // multiline hash comments\n              shortcutStylePatterns.push(\n                  [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n            } else {\n              // Stop C preprocessor declarations at an unclosed open comment\n              shortcutStylePatterns.push(\n                  [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n                   null, '#']);\n            }\n            // #include <stdio.h>\n            fallthroughStylePatterns.push(\n                [PR_STRING,\n                 /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n                 null]);\n          } else {\n            shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n          }\n        }\n        if (options['cStyleComments']) {\n          fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n          fallthroughStylePatterns.push(\n              [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n        }\n        var regexLiterals = options['regexLiterals'];\n        if (regexLiterals) {\n          /**\n           * @const\n           */\n          var regexExcls = regexLiterals > 1\n            ? ''  // Multiline regex literals\n            : '\\n\\r';\n          /**\n           * @const\n           */\n          var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n          /**\n           * @const\n           */\n          var REGEX_LITERAL = (\n              // A regular expression literal starts with a slash that is\n              // not followed by * or / so that it is not confused with\n              // comments.\n              '/(?=[^/*' + regexExcls + '])'\n              // and then contains any number of raw characters,\n              + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n              // escape sequences (\\x5C),\n              +    '|\\\\x5C' + regexAny\n              // or non-nesting character sets (\\x5B\\x5D);\n              +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n              +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n              // finally closed by a /.\n              + '/');\n          fallthroughStylePatterns.push(\n              ['lang-regex',\n               RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n               ]);\n        }\n    \n        var types = options['types'];\n        if (types) {\n          fallthroughStylePatterns.push([PR_TYPE, types]);\n        }\n    \n        var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n        if (keywords.length) {\n          fallthroughStylePatterns.push(\n              [PR_KEYWORD,\n               new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n               null]);\n        }\n    \n        shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n    \n        var punctuation =\n          // The Bash man page says\n    \n          // A word is a sequence of characters considered as a single\n          // unit by GRUB. Words are separated by metacharacters,\n          // which are the following plus space, tab, and newline: { }\n          // | & $ ; < >\n          // ...\n    \n          // A word beginning with # causes that word and all remaining\n          // characters on that line to be ignored.\n    \n          // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n          // comment but empirically\n          // $ echo {#}\n          // {#}\n          // $ echo \\$#\n          // $#\n          // $ echo }#\n          // }#\n    \n          // so /(?:^|[|&;<>\\s])/ is more appropriate.\n    \n          // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n          // suggests that this definition is compatible with a\n          // default mode that tries to use a single token definition\n          // to recognize both bash/python style comments and C\n          // preprocessor directives.\n    \n          // This definition of punctuation does not include # in the list of\n          // follow-on exclusions, so # will not be broken before if preceeded\n          // by a punctuation character.  We could try to exclude # after\n          // [|&;<>] but that doesn't seem to cause many major problems.\n          // If that does turn out to be a problem, we should change the below\n          // when hc is truthy to include # in the run of punctuation characters\n          // only when not followint [|&;<>].\n          '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n        if (options['regexLiterals']) {\n          punctuation += '(?!\\s*\\/)';\n        }\n    \n        fallthroughStylePatterns.push(\n            // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n            [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n            [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n            [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n            [PR_LITERAL,\n             new RegExp(\n                 '^(?:'\n                 // A hex number\n                 + '0x[a-f0-9]+'\n                 // or an octal or decimal number,\n                 + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n                 // possibly in scientific notation\n                 + '(?:e[+\\\\-]?\\\\d+)?'\n                 + ')'\n                 // with an optional modifier like UL for unsigned long\n                 + '[a-z]*', 'i'),\n             null, '0123456789'],\n            // Don't treat escaped quotes in bash as starting strings.\n            // See issue 144.\n            [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n            [PR_PUNCTUATION, new RegExp(punctuation), null]);\n    \n        return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n      }\n    \n      var decorateSource = sourceDecorator({\n            'keywords': ALL_KEYWORDS,\n            'hashComments': true,\n            'cStyleComments': true,\n            'multiLineStrings': true,\n            'regexLiterals': true\n          });\n    \n      /**\n       * Given a DOM subtree, wraps it in a list, and puts each line into its own\n       * list item.\n       *\n       * @param {Node} node modified in place.  Its content is pulled into an\n       *     HTMLOListElement, and each line is moved into a separate list item.\n       *     This requires cloning elements, so the input might not have unique\n       *     IDs after numbering.\n       * @param {number|null|boolean} startLineNum\n       *     If truthy, coerced to an integer which is the 1-indexed line number\n       *     of the first line of code.  The number of the first line will be\n       *     attached to the list.\n       * @param {boolean} isPreformatted true iff white-space in text nodes should\n       *     be treated as significant.\n       */\n      function numberLines(node, startLineNum, isPreformatted) {\n        var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n        var lineBreak = /\\r\\n?|\\n/;\n      \n        var document = node.ownerDocument;\n      \n        var li = document.createElement('li');\n        while (node.firstChild) {\n          li.appendChild(node.firstChild);\n        }\n        // An array of lines.  We split below, so this is initialized to one\n        // un-split line.\n        var listItems = [li];\n      \n        function walk(node) {\n          var type = node.nodeType;\n          if (type == 1 && !nocode.test(node.className)) {  // Element\n            if ('br' === node.nodeName) {\n              breakAfter(node);\n              // Discard the <BR> since it is now flush against a </LI>.\n              if (node.parentNode) {\n                node.parentNode.removeChild(node);\n              }\n            } else {\n              for (var child = node.firstChild; child; child = child.nextSibling) {\n                walk(child);\n              }\n            }\n          } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n            var text = node.nodeValue;\n            var match = text.match(lineBreak);\n            if (match) {\n              var firstLine = text.substring(0, match.index);\n              node.nodeValue = firstLine;\n              var tail = text.substring(match.index + match[0].length);\n              if (tail) {\n                var parent = node.parentNode;\n                parent.insertBefore(\n                  document.createTextNode(tail), node.nextSibling);\n              }\n              breakAfter(node);\n              if (!firstLine) {\n                // Don't leave blank text nodes in the DOM.\n                node.parentNode.removeChild(node);\n              }\n            }\n          }\n        }\n      \n        // Split a line after the given node.\n        function breakAfter(lineEndNode) {\n          // If there's nothing to the right, then we can skip ending the line\n          // here, and move root-wards since splitting just before an end-tag\n          // would require us to create a bunch of empty copies.\n          while (!lineEndNode.nextSibling) {\n            lineEndNode = lineEndNode.parentNode;\n            if (!lineEndNode) { return; }\n          }\n      \n          function breakLeftOf(limit, copy) {\n            // Clone shallowly if this node needs to be on both sides of the break.\n            var rightSide = copy ? limit.cloneNode(false) : limit;\n            var parent = limit.parentNode;\n            if (parent) {\n              // We clone the parent chain.\n              // This helps us resurrect important styling elements that cross lines.\n              // E.g. in <i>Foo<br>Bar</i>\n              // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n              var parentClone = breakLeftOf(parent, 1);\n              // Move the clone and everything to the right of the original\n              // onto the cloned parent.\n              var next = limit.nextSibling;\n              parentClone.appendChild(rightSide);\n              for (var sibling = next; sibling; sibling = next) {\n                next = sibling.nextSibling;\n                parentClone.appendChild(sibling);\n              }\n            }\n            return rightSide;\n          }\n      \n          var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n      \n          // Walk the parent chain until we reach an unattached LI.\n          for (var parent;\n               // Check nodeType since IE invents document fragments.\n               (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n            copiedListItem = parent;\n          }\n          // Put it on the list of lines for later processing.\n          listItems.push(copiedListItem);\n        }\n      \n        // Split lines while there are lines left to split.\n        for (var i = 0;  // Number of lines that have been split so far.\n             i < listItems.length;  // length updated by breakAfter calls.\n             ++i) {\n          walk(listItems[i]);\n        }\n      \n        // Make sure numeric indices show correctly.\n        if (startLineNum === (startLineNum|0)) {\n          listItems[0].setAttribute('value', startLineNum);\n        }\n      \n        var ol = document.createElement('ol');\n        ol.className = 'linenums';\n        var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n        for (var i = 0, n = listItems.length; i < n; ++i) {\n          li = listItems[i];\n          // Stick a class on the LIs so that stylesheets can\n          // color odd/even rows, or any other row pattern that\n          // is co-prime with 10.\n          li.className = 'L' + ((i + offset) % 10);\n          if (!li.firstChild) {\n            li.appendChild(document.createTextNode('\\xA0'));\n          }\n          ol.appendChild(li);\n        }\n      \n        node.appendChild(ol);\n      }\n    \n      /**\n       * Breaks {@code job.sourceCode} around style boundaries in\n       * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n       * @param {JobT} job\n       * @private\n       */\n      function recombineTagsAndDecorations(job) {\n        var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n        isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n        var newlineRe = /\\n/g;\n      \n        var source = job.sourceCode;\n        var sourceLength = source.length;\n        // Index into source after the last code-unit recombined.\n        var sourceIndex = 0;\n      \n        var spans = job.spans;\n        var nSpans = spans.length;\n        // Index into spans after the last span which ends at or before sourceIndex.\n        var spanIndex = 0;\n      \n        var decorations = job.decorations;\n        var nDecorations = decorations.length;\n        // Index into decorations after the last decoration which ends at or before\n        // sourceIndex.\n        var decorationIndex = 0;\n      \n        // Remove all zero-length decorations.\n        decorations[nDecorations] = sourceLength;\n        var decPos, i;\n        for (i = decPos = 0; i < nDecorations;) {\n          if (decorations[i] !== decorations[i + 2]) {\n            decorations[decPos++] = decorations[i++];\n            decorations[decPos++] = decorations[i++];\n          } else {\n            i += 2;\n          }\n        }\n        nDecorations = decPos;\n      \n        // Simplify decorations.\n        for (i = decPos = 0; i < nDecorations;) {\n          var startPos = decorations[i];\n          // Conflate all adjacent decorations that use the same style.\n          var startDec = decorations[i + 1];\n          var end = i + 2;\n          while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n            end += 2;\n          }\n          decorations[decPos++] = startPos;\n          decorations[decPos++] = startDec;\n          i = end;\n        }\n      \n        nDecorations = decorations.length = decPos;\n      \n        var sourceNode = job.sourceNode;\n        var oldDisplay = \"\";\n        if (sourceNode) {\n          oldDisplay = sourceNode.style.display;\n          sourceNode.style.display = 'none';\n        }\n        try {\n          var decoration = null;\n          while (spanIndex < nSpans) {\n            var spanStart = spans[spanIndex];\n            var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n                || sourceLength;\n      \n            var decEnd = decorations[decorationIndex + 2] || sourceLength;\n      \n            var end = Math.min(spanEnd, decEnd);\n      \n            var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n            var styledText;\n            if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n                // Don't introduce spans around empty text nodes.\n                && (styledText = source.substring(sourceIndex, end))) {\n              // This may seem bizarre, and it is.  Emitting LF on IE causes the\n              // code to display with spaces instead of line breaks.\n              // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n              // space to appear at the beginning of every line but the first.\n              // Emitting an old Mac OS 9 line separator makes everything spiffy.\n              if (isIE8OrEarlier) {\n                styledText = styledText.replace(newlineRe, '\\r');\n              }\n              textNode.nodeValue = styledText;\n              var document = textNode.ownerDocument;\n              var span = document.createElement('span');\n              span.className = decorations[decorationIndex + 1];\n              var parentNode = textNode.parentNode;\n              parentNode.replaceChild(span, textNode);\n              span.appendChild(textNode);\n              if (sourceIndex < spanEnd) {  // Split off a text node.\n                spans[spanIndex + 1] = textNode\n                    // TODO: Possibly optimize by using '' if there's no flicker.\n                    = document.createTextNode(source.substring(end, spanEnd));\n                parentNode.insertBefore(textNode, span.nextSibling);\n              }\n            }\n      \n            sourceIndex = end;\n      \n            if (sourceIndex >= spanEnd) {\n              spanIndex += 2;\n            }\n            if (sourceIndex >= decEnd) {\n              decorationIndex += 2;\n            }\n          }\n        } finally {\n          if (sourceNode) {\n            sourceNode.style.display = oldDisplay;\n          }\n        }\n      }\n    \n      /** Maps language-specific file extensions to handlers. */\n      var langHandlerRegistry = {};\n      /** Register a language handler for the given file extensions.\n        * @param {function (JobT)} handler a function from source code to a list\n        *      of decorations.  Takes a single argument job which describes the\n        *      state of the computation and attaches the decorations to it.\n        * @param {Array.<string>} fileExtensions\n        */\n      function registerLangHandler(handler, fileExtensions) {\n        for (var i = fileExtensions.length; --i >= 0;) {\n          var ext = fileExtensions[i];\n          if (!langHandlerRegistry.hasOwnProperty(ext)) {\n            langHandlerRegistry[ext] = handler;\n          } else if (win['console']) {\n            console['warn']('cannot override language handler %s', ext);\n          }\n        }\n      }\n      function langHandlerForExtension(extension, source) {\n        if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n          // Treat it as markup if the first non whitespace character is a < and\n          // the last non-whitespace character is a >.\n          extension = /^\\s*</.test(source)\n              ? 'default-markup'\n              : 'default-code';\n        }\n        return langHandlerRegistry[extension];\n      }\n      registerLangHandler(decorateSource, ['default-code']);\n      registerLangHandler(\n          createSimpleLexer(\n              [],\n              [\n               [PR_PLAIN,       /^[^<?]+/],\n               [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n               [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n               // Unescaped content in an unknown language\n               ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n               ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n               [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n               ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n               // Unescaped content in javascript.  (Or possibly vbscript).\n               ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n               // Contains unescaped stylesheet content\n               ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n               ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n              ]),\n          ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n      registerLangHandler(\n          createSimpleLexer(\n              [\n               [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n               [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n               ],\n              [\n               [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n               [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n               ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n               [PR_PUNCTUATION,  /^[=<>\\/]+/],\n               ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n               ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n               ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n               ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n               ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n               ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n               ]),\n          ['in.tag']);\n      registerLangHandler(\n          createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n      registerLangHandler(sourceDecorator({\n              'keywords': CPP_KEYWORDS,\n              'hashComments': true,\n              'cStyleComments': true,\n              'types': C_TYPES\n            }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n      registerLangHandler(sourceDecorator({\n              'keywords': 'null,true,false'\n            }), ['json']);\n      registerLangHandler(sourceDecorator({\n              'keywords': CSHARP_KEYWORDS,\n              'hashComments': true,\n              'cStyleComments': true,\n              'verbatimStrings': true,\n              'types': C_TYPES\n            }), ['cs']);\n      registerLangHandler(sourceDecorator({\n              'keywords': JAVA_KEYWORDS,\n              'cStyleComments': true\n            }), ['java']);\n      registerLangHandler(sourceDecorator({\n              'keywords': SH_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true\n            }), ['bash', 'bsh', 'csh', 'sh']);\n      registerLangHandler(sourceDecorator({\n              'keywords': PYTHON_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true,\n              'tripleQuotedStrings': true\n            }), ['cv', 'py', 'python']);\n      registerLangHandler(sourceDecorator({\n              'keywords': PERL_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true,\n              'regexLiterals': 2  // multiline regex literals\n            }), ['perl', 'pl', 'pm']);\n      registerLangHandler(sourceDecorator({\n              'keywords': RUBY_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true,\n              'regexLiterals': true\n            }), ['rb', 'ruby']);\n      registerLangHandler(sourceDecorator({\n              'keywords': JSCRIPT_KEYWORDS,\n              'cStyleComments': true,\n              'regexLiterals': true\n            }), ['javascript', 'js', 'ts', 'typescript']);\n      registerLangHandler(sourceDecorator({\n              'keywords': COFFEE_KEYWORDS,\n              'hashComments': 3,  // ### style block comments\n              'cStyleComments': true,\n              'multilineStrings': true,\n              'tripleQuotedStrings': true,\n              'regexLiterals': true\n            }), ['coffee']);\n      registerLangHandler(\n          createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n    \n      /** @param {JobT} job */\n      function applyDecorator(job) {\n        var opt_langExtension = job.langExtension;\n    \n        try {\n          // Extract tags, and convert the source code to plain text.\n          var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n          /** Plain text. @type {string} */\n          var source = sourceAndSpans.sourceCode;\n          job.sourceCode = source;\n          job.spans = sourceAndSpans.spans;\n          job.basePos = 0;\n    \n          // Apply the appropriate language handler\n          langHandlerForExtension(opt_langExtension, source)(job);\n    \n          // Integrate the decorations and tags back into the source code,\n          // modifying the sourceNode in place.\n          recombineTagsAndDecorations(job);\n        } catch (e) {\n          if (win['console']) {\n            console['log'](e && e['stack'] || e);\n          }\n        }\n      }\n    \n      /**\n       * Pretty print a chunk of code.\n       * @param sourceCodeHtml {string} The HTML to pretty print.\n       * @param opt_langExtension {string} The language name to use.\n       *     Typically, a filename extension like 'cpp' or 'java'.\n       * @param opt_numberLines {number|boolean} True to number lines,\n       *     or the 1-indexed number of the first line in sourceCodeHtml.\n       */\n      function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n        /** @type{number|boolean} */\n        var nl = opt_numberLines || false;\n        /** @type{string|null} */\n        var langExtension = opt_langExtension || null;\n        /** @type{!Element} */\n        var container = document.createElement('div');\n        // This could cause images to load and onload listeners to fire.\n        // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n        // We assume that the inner HTML is from a trusted source.\n        // The pre-tag is required for IE8 which strips newlines from innerHTML\n        // when it is injected into a <pre> tag.\n        // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n        // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n        container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n        container = /** @type{!Element} */(container.firstChild);\n        if (nl) {\n          numberLines(container, nl, true);\n        }\n    \n        /** @type{JobT} */\n        var job = {\n          langExtension: langExtension,\n          numberLines: nl,\n          sourceNode: container,\n          pre: 1,\n          sourceCode: null,\n          basePos: null,\n          spans: null,\n          decorations: null\n        };\n        applyDecorator(job);\n        return container.innerHTML;\n      }\n    \n       /**\n        * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n        * {@code class=prettyprint} and prettify them.\n        *\n        * @param {Function} opt_whenDone called when prettifying is done.\n        * @param {HTMLElement|HTMLDocument} opt_root an element or document\n        *   containing all the elements to pretty print.\n        *   Defaults to {@code document.body}.\n        */\n      function $prettyPrint(opt_whenDone, opt_root) {\n        var root = opt_root || document.body;\n        var doc = root.ownerDocument || document;\n        function byTagName(tn) { return root.getElementsByTagName(tn); }\n        // fetch a list of nodes to rewrite\n        var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n        var elements = [];\n        for (var i = 0; i < codeSegments.length; ++i) {\n          for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n            elements.push(codeSegments[i][j]);\n          }\n        }\n        codeSegments = null;\n    \n        var clock = Date;\n        if (!clock['now']) {\n          clock = { 'now': function () { return +(new Date); } };\n        }\n    \n        // The loop is broken into a series of continuations to make sure that we\n        // don't make the browser unresponsive when rewriting a large page.\n        var k = 0;\n    \n        var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n        var prettyPrintRe = /\\bprettyprint\\b/;\n        var prettyPrintedRe = /\\bprettyprinted\\b/;\n        var preformattedTagNameRe = /pre|xmp/i;\n        var codeRe = /^code$/i;\n        var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n        var EMPTY = {};\n    \n        function doWork() {\n          var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                         clock['now']() + 250 /* ms */ :\n                         Infinity);\n          for (; k < elements.length && clock['now']() < endTime; k++) {\n            var cs = elements[k];\n    \n            // Look for a preceding comment like\n            // <?prettify lang=\"...\" linenums=\"...\"?>\n            var attrs = EMPTY;\n            {\n              for (var preceder = cs; (preceder = preceder.previousSibling);) {\n                var nt = preceder.nodeType;\n                // <?foo?> is parsed by HTML 5 to a comment node (8)\n                // like <!--?foo?-->, but in XML is a processing instruction\n                var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n                if (value\n                    ? !/^\\??prettify\\b/.test(value)\n                    : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n                  // Skip over white-space text nodes but not others.\n                  break;\n                }\n                if (value) {\n                  attrs = {};\n                  value.replace(\n                      /\\b(\\w+)=([\\w:.%+-]+)/g,\n                    function (_, name, value) { attrs[name] = value; });\n                  break;\n                }\n              }\n            }\n    \n            var className = cs.className;\n            if ((attrs !== EMPTY || prettyPrintRe.test(className))\n                // Don't redo this if we've already done it.\n                // This allows recalling pretty print to just prettyprint elements\n                // that have been added to the page since last call.\n                && !prettyPrintedRe.test(className)) {\n    \n              // make sure this is not nested in an already prettified element\n              var nested = false;\n              for (var p = cs.parentNode; p; p = p.parentNode) {\n                var tn = p.tagName;\n                if (preCodeXmpRe.test(tn)\n                    && p.className && prettyPrintRe.test(p.className)) {\n                  nested = true;\n                  break;\n                }\n              }\n              if (!nested) {\n                // Mark done.  If we fail to prettyprint for whatever reason,\n                // we shouldn't try again.\n                cs.className += ' prettyprinted';\n    \n                // If the classes includes a language extensions, use it.\n                // Language extensions can be specified like\n                //     <pre class=\"prettyprint lang-cpp\">\n                // the language extension \"cpp\" is used to find a language handler\n                // as passed to PR.registerLangHandler.\n                // HTML5 recommends that a language be specified using \"language-\"\n                // as the prefix instead.  Google Code Prettify supports both.\n                // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n                var langExtension = attrs['lang'];\n                if (!langExtension) {\n                  langExtension = className.match(langExtensionRe);\n                  // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n                  var wrapper;\n                  if (!langExtension && (wrapper = childContentWrapper(cs))\n                      && codeRe.test(wrapper.tagName)) {\n                    langExtension = wrapper.className.match(langExtensionRe);\n                  }\n    \n                  if (langExtension) { langExtension = langExtension[1]; }\n                }\n    \n                var preformatted;\n                if (preformattedTagNameRe.test(cs.tagName)) {\n                  preformatted = 1;\n                } else {\n                  var currentStyle = cs['currentStyle'];\n                  var defaultView = doc.defaultView;\n                  var whitespace = (\n                      currentStyle\n                      ? currentStyle['whiteSpace']\n                      : (defaultView\n                         && defaultView.getComputedStyle)\n                      ? defaultView.getComputedStyle(cs, null)\n                      .getPropertyValue('white-space')\n                      : 0);\n                  preformatted = whitespace\n                      && 'pre' === whitespace.substring(0, 3);\n                }\n    \n                // Look for a class like linenums or linenums:<n> where <n> is the\n                // 1-indexed number of the first line.\n                var lineNums = attrs['linenums'];\n                if (!(lineNums = lineNums === 'true' || +lineNums)) {\n                  lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n                  lineNums =\n                    lineNums\n                    ? lineNums[1] && lineNums[1].length\n                      ? +lineNums[1] : true\n                    : false;\n                }\n                if (lineNums) { numberLines(cs, lineNums, preformatted); }\n    \n                // do the pretty printing\n                var prettyPrintingJob = {\n                  langExtension: langExtension,\n                  sourceNode: cs,\n                  numberLines: lineNums,\n                  pre: preformatted,\n                  sourceCode: null,\n                  basePos: null,\n                  spans: null,\n                  decorations: null\n                };\n                applyDecorator(prettyPrintingJob);\n              }\n            }\n          }\n          if (k < elements.length) {\n            // finish up in a continuation\n            win.setTimeout(doWork, 250);\n          } else if ('function' === typeof opt_whenDone) {\n            opt_whenDone();\n          }\n        }\n    \n        doWork();\n      }\n    \n      /**\n       * Contains functions for creating and registering new language handlers.\n       * @type {Object}\n       */\n      var PR = win['PR'] = {\n            'createSimpleLexer': createSimpleLexer,\n            'registerLangHandler': registerLangHandler,\n            'sourceDecorator': sourceDecorator,\n            'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n            'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n            'PR_COMMENT': PR_COMMENT,\n            'PR_DECLARATION': PR_DECLARATION,\n            'PR_KEYWORD': PR_KEYWORD,\n            'PR_LITERAL': PR_LITERAL,\n            'PR_NOCODE': PR_NOCODE,\n            'PR_PLAIN': PR_PLAIN,\n            'PR_PUNCTUATION': PR_PUNCTUATION,\n            'PR_SOURCE': PR_SOURCE,\n            'PR_STRING': PR_STRING,\n            'PR_TAG': PR_TAG,\n            'PR_TYPE': PR_TYPE,\n            'prettyPrintOne':\n               IN_GLOBAL_SCOPE\n                 ? (win['prettyPrintOne'] = $prettyPrintOne)\n                 : (prettyPrintOne = $prettyPrintOne),\n            'prettyPrint': prettyPrint =\n               IN_GLOBAL_SCOPE\n                 ? (win['prettyPrint'] = $prettyPrint)\n                 : (prettyPrint = $prettyPrint)\n          };\n    \n      // Make PR available via the Asynchronous Module Definition (AMD) API.\n      // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n      // The Asynchronous Module Definition (AMD) API specifies a\n      // mechanism for defining modules such that the module and its\n      // dependencies can be asynchronously loaded.\n      // ...\n      // To allow a clear indicator that a global define function (as\n      // needed for script src browser loading) conforms to the AMD API,\n      // any global define function SHOULD have a property called \"amd\"\n      // whose value is an object. This helps avoid conflict with any\n      // other existing JavaScript code that could have defined a define()\n      // function that does not conform to the AMD API.\n      var define = win['define'];\n      if (typeof define === \"function\" && define['amd']) {\n        define(\"google-code-prettify\", [], function () {\n          return PR;\n        });\n      }\n    })();\n    return prettyPrint;\n  })();\n\n  // If this script is deferred or async and the document is already\n  // loaded we need to wait for language handlers to load before performing\n  // any autorun.\n  function onLangsLoaded() {\n    if (autorun) {\n      contentLoaded(\n        function () {\n          var n = callbacks.length;\n          var callback = n ? function () {\n            for (var i = 0; i < n; ++i) {\n              (function (i) {\n                win.setTimeout(\n                   function () {\n                     win['exports'][callbacks[i]].apply(win, arguments);\n                   }, 0);\n               })(i);\n            }\n          } : void 0;\n          prettyPrint(callback);\n        });\n    }\n  }\n  checkPendingLanguages();\n\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8954670b71fa2f188835","/*global window, global*/\nvar util = require(\"util\")\nvar assert = require(\"assert\")\nvar now = require(\"date-now\")\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof global !== \"undefined\" && global.console) {\n    console = global.console\n} else if (typeof window !== \"undefined\" && window.console) {\n    console = window.console\n} else {\n    console = {}\n}\n\nvar functions = [\n    [log, \"log\"],\n    [info, \"info\"],\n    [warn, \"warn\"],\n    [error, \"error\"],\n    [time, \"time\"],\n    [timeEnd, \"timeEnd\"],\n    [trace, \"trace\"],\n    [dir, \"dir\"],\n    [consoleAssert, \"assert\"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error(\"No such label: \" + label)\n    }\n\n    var duration = now() - time\n    console.log(label + \": \" + duration + \"ms\")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = \"Trace\"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + \"\\n\")\n}\n\nfunction consoleAssert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/console-browserify/index.js\n// module id = 0\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/util.js\n// module id = 2\n// module chunks = 0","import '../css/prettify.css';\nimport '../css/style.css';\nimport '../../node_modules/code-prettify/styles/sunburst.css';\n\nrequire('code-prettify');\nrequire('code-prettify/src/run_prettify');\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/index.js","/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n\n/**\n* @typedef {!Array.<number|string>}\n* Alternating indices and the decorations that should be inserted there.\n* The indices are monotonically increasing.\n*/\nvar DecorationsT;\n\n/**\n* @typedef {!{\n*   sourceNode: !Element,\n*   pre: !(number|boolean),\n*   langExtension: ?string,\n*   numberLines: ?(number|boolean),\n*   sourceCode: ?string,\n*   spans: ?(Array.<number|Node>),\n*   basePos: ?number,\n*   decorations: ?DecorationsT\n* }}\n* <dl>\n*  <dt>sourceNode<dd>the element containing the source\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>pre<dd>truthy if white-space in text nodes\n*     should be considered significant.\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n*  <dt>decorations<dd>an array of style classes preceded\n*     by the position at which they start in job.sourceCode in order\n*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n*     source.\n* </dl>\n*/\nvar JobT;\n\n/**\n* @typedef {!{\n*   sourceCode: string,\n*   spans: !(Array.<number|Node>)\n* }}\n* <dl>\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n* </dl>\n*/\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = false;\n\nvar HACK_TO_FIX_JS_INCLUDE_PL;\n\n/**\n * {@type !{\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * }}\n * @const\n */\nvar PR;\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n/**\n * Pretty print a chunk of code.\n * @param {string} sourceCodeHtml The HTML to pretty print.\n * @param {string} opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param {number|boolean} opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return {string} code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n * {@code class=prettyprint} and prettify them.\n *\n * @param {Function} opt_whenDone called when prettifying is done.\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to {@code document.body}.\n */\nvar prettyPrint;\n\n\n(function () {\n  var win = window;\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n      \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" +\n      \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" +\n      \"yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n  \n  \n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * <p>The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n  \n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n  \n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n  \n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n  \n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n  \n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    }\n  \n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n  \n      var out = ['['];\n      if (inverse) { out.push('^'); }\n  \n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          out.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n  \n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n  \n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n  \n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n  \n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n  \n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue) {\n            if (decimalValue <= groupIndex) {\n              capturedGroups[decimalValue] = -1;\n            } else {\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            }\n          }\n        }\n      }\n  \n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          }\n        }\n      }\n  \n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n  \n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n  \n      return parts.join('');\n    }\n  \n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n  \n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @param {boolean|number} isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return {SourceSpansT} source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n  \n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n  \n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1) {  // Element\n        if (nocode.test(node.className)) { return; }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) {\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        }\n      } else if (type == 3 || type == 4) {  // Text\n        var text = node.nodeValue;\n        if (text.length) {\n          if (!isPreformatted) {\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          } else {\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          }\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        }\n      }\n    }\n  \n    walk(node);\n  \n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {!Element} sourceNode\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param {string} sourceCode\n   * @param {function(JobT)} langHandler\n   * @param {DecorationsT} out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    /** @type {JobT} */\n    var job = {\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo {#}\n      // {#}\n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n  \n    var document = node.ownerDocument;\n  \n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n  \n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n  \n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n  \n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n  \n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n  \n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n  \n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n  \n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n  \n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n  \n    node.appendChild(ol);\n  }\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n  \n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n  \n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n  \n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n  \n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n  \n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n  \n    nDecorations = decorations.length = decPos;\n  \n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n  \n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n  \n        var end = Math.min(spanEnd, decEnd);\n  \n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n  \n        sourceIndex = end;\n  \n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint': prettyPrint =\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/code-prettify/src/prettify.js\n// module id = 7\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 8\n// module chunks = 0","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/support/isBufferBrowser.js\n// module id = 9\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/node_modules/inherits/inherits_browser.js\n// module id = 10\n// module chunks = 0","'use strict';\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/assert/assert.js\n// module id = 11\n// module chunks = 0","module.exports = now\n\nfunction now() {\n    return new Date().getTime()\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/date-now/index.js\n// module id = 12\n// module chunks = 0","/**\n * @license\n * Copyright (C) 2013 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * <div style=\"white-space: pre\">\n * Looks at query parameters to decide which language handlers and style-sheets\n * to load.\n *\n * Query Parameter     Format           Effect                        Default\n * +------------------+---------------+------------------------------+--------+\n * | autorun=         | true | false  | If true then prettyPrint()   | \"true\" |\n * |                  |               | is called on page load.      |        |\n * +------------------+---------------+------------------------------+--------+\n * | lang=            | language name | Loads the language handler   | Can    |\n * |                  |               | named \"lang-<NAME>.js\".      | appear |\n * |                  |               | See available handlers at    | many   |\n * |                  |               | https://github.com/google/   | times. |\n * |                  |               | code-prettify/tree/master/   |        |\n * |                  |               | src                          |        |\n * +------------------+---------------+------------------------------+--------+\n * | skin=            | skin name     | Loads the skin stylesheet    | none.  |\n * |                  |               | named \"<NAME>.css\".          |        |\n * |                  |               | https://cdn.rawgit.com/      |        |\n * |                  |               | google/code-prettify/master/ |        |\n * |                  |               | styles/index.html            |        |\n * +------------------+---------------+------------------------------+--------+\n * | callback=        | JS identifier | When \"prettyPrint\" finishes  | none   |\n * |                  |               | window.exports[js_ident] is  |        |\n * |                  |               | called.                      |        |\n * |                  |               | The callback must be under   |        |\n * |                  |               | exports to reduce the risk   |        |\n * |                  |               | of XSS via query parameter   |        |\n * |                  |               | injection.                   |        |\n * +------------------+---------------+------------------------------+--------+\n *\n * Exmaples\n * .../run_prettify.js?lang=css&skin=sunburst\n *   1. Loads the CSS language handler which can be used to prettify CSS\n *      stylesheets, HTML <style> element bodies and style=\"...\" attributes\n *      values.\n *   2. Loads the sunburst.css stylesheet instead of the default prettify.css\n *      stylesheet.\n *      A gallery of stylesheets is available at\n *      https://cdn.rawgit.com/google/code-prettify/master/styles/index.html\n *   3. Since autorun=false is not specified, calls prettyPrint() on page load.\n * </div>\n */\n\n/**\n* @typedef {!Array.<number|string>}\n* Alternating indices and the decorations that should be inserted there.\n* The indices are monotonically increasing.\n*/\nvar DecorationsT;\n\n/**\n* @typedef {!{\n*   sourceNode: !Element,\n*   pre: !(number|boolean),\n*   langExtension: ?string,\n*   numberLines: ?(number|boolean),\n*   sourceCode: ?string,\n*   spans: ?(Array.<number|Node>),\n*   basePos: ?number,\n*   decorations: ?DecorationsT\n* }}\n* <dl>\n*  <dt>sourceNode<dd>the element containing the source\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>pre<dd>truthy if white-space in text nodes\n*     should be considered significant.\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n*  <dt>decorations<dd>an array of style classes preceded\n*     by the position at which they start in job.sourceCode in order\n*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n*     source.\n* </dl>\n*/\nvar JobT;\n\n/**\n* @typedef {!{\n*   sourceCode: string,\n*   spans: !(Array.<number|Node>)\n* }}\n* <dl>\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n* </dl>\n*/\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = false;\n\n(function () {\n  \"use strict\";\n\n  var win = window;\n  var doc = document;\n  var root = doc.documentElement;\n  var head = doc['head'] || doc.getElementsByTagName(\"head\")[0] || root;\n\n  // From http://javascript.nwbox.com/ContentLoaded/contentloaded.js\n  // Author: Diego Perini (diego.perini at gmail.com)\n  // Summary: cross-browser wrapper for DOMContentLoaded\n  // Updated: 20101020\n  // License: MIT\n  // Version: 1.2\n  function contentLoaded(callback) {\n    var addEventListener = doc['addEventListener'];\n    var done = false, top = true,\n        add = addEventListener ? 'addEventListener' : 'attachEvent',\n        rem = addEventListener ? 'removeEventListener' : 'detachEvent',\n        pre = addEventListener ? '' : 'on',\n\n        init = function(e) {\n          if (e.type == 'readystatechange' && doc.readyState != 'complete') {\n            return;\n          }\n          (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);\n          if (!done && (done = true)) { callback.call(win, e.type || e); }\n        },\n\n        poll = function() {\n          try {\n            root.doScroll('left');\n          } catch(e) {\n            win.setTimeout(poll, 50);\n            return;\n          }\n          init('poll');\n        };\n\n    if (doc.readyState == 'complete') {\n      callback.call(win, 'lazy');\n    } else {\n      if (doc.createEventObject && root.doScroll) {\n        try { top = !win.frameElement; } catch(e) { }\n        if (top) { poll(); }\n      }\n      doc[add](pre + 'DOMContentLoaded', init, false);\n      doc[add](pre + 'readystatechange', init, false);\n      win[add](pre + 'load', init, false);\n    }\n  }\n\n  // Given a list of URLs to stylesheets, loads the first that loads without\n  // triggering an error event.\n  function loadStylesheetsFallingBack(stylesheets) {\n    var n = stylesheets.length;\n    function load(i) {\n      if (i === n) { return; }\n      var link = doc.createElement('link');\n      link.rel = 'stylesheet';\n      link.type = 'text/css';\n      if (i + 1 < n) {\n        // http://pieisgood.org/test/script-link-events/ indicates that many\n        // versions of IE do not support onerror on <link>s, though\n        // http://msdn.microsoft.com/en-us/library/ie/ms535848(v=vs.85).aspx\n        // indicates that recent IEs do support error.\n        link.error = link.onerror = function () { load(i + 1); };\n      }\n      link.href = stylesheets[i];\n      head.appendChild(link);\n    }\n    load(0);\n  }\n\n  var scriptQuery = '';\n  // Look for the <script> node that loads this script to get its parameters.\n  // This starts looking at the end instead of just considering the last\n  // because deferred and async scripts run out of order.\n  // If the script is loaded twice, then this will run in reverse order.\n  var scripts = doc.getElementsByTagName('script');\n  for (var i = scripts.length; --i >= 0;) {\n    var script = scripts[i];\n    var match = script.src.match(\n        /^[^?#]*\\/run_prettify\\.js(\\?[^#]*)?(?:#.*)?$/);\n    if (match) {\n      scriptQuery = match[1] || '';\n      // Remove the script from the DOM so that multiple runs at least run\n      // multiple times even if parameter sets are interpreted in reverse\n      // order.\n      script.parentNode.removeChild(script);\n      break;\n    }\n  }\n\n  // Pull parameters into local variables.\n  var autorun = true;\n  var langs = [];\n  var skins = [];\n  var callbacks = [];\n  scriptQuery.replace(\n      /[?&]([^&=]+)=([^&]+)/g,\n      function (_, name, value) {\n        value = decodeURIComponent(value);\n        name = decodeURIComponent(name);\n        if (name == 'autorun')   { autorun = !/^[0fn]/i.test(value); } else\n        if (name == 'lang')      { langs.push(value);                } else\n        if (name == 'skin')      { skins.push(value);                } else\n        if (name == 'callback')  { callbacks.push(value);            }\n      });\n\n  // Use https to avoid mixed content warnings in client pages and to\n  // prevent a MITM from rewrite prettify mid-flight.\n  // This only works if this script is loaded via https : something\n  // over which we exercise no control.\n  var LOADER_BASE_URL =\n     'https://cdn.rawgit.com/google/code-prettify/master/loader';\n\n  for (var i = 0, n = langs.length; i < n; ++i) (function (lang) {\n    var script = doc.createElement(\"script\");\n\n    // Excerpted from jQuery.ajaxTransport(\"script\") to fire events when\n    // a script is finished loading.\n    // Attach handlers for each script\n    script.onload = script.onerror = script.onreadystatechange = function () {\n      if (script && (\n            !script.readyState || /loaded|complete/.test(script.readyState))) {\n        // Handle memory leak in IE\n        script.onerror = script.onload = script.onreadystatechange = null;\n\n        --pendingLanguages;\n        checkPendingLanguages();\n\n        // Remove the script\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n\n        script = null;\n      }\n    };\n\n    script.type = 'text/javascript';\n    script.src = LOADER_BASE_URL\n      + '/lang-' + encodeURIComponent(langs[i]) + '.js';\n\n    // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n    head.insertBefore(script, head.firstChild);\n  })(langs[i]);\n\n  var pendingLanguages = langs.length;\n  function checkPendingLanguages() {\n    if (!pendingLanguages) {\n      win.setTimeout(onLangsLoaded, 0);\n    }\n  }\n\n  var skinUrls = [];\n  for (var i = 0, n = skins.length; i < n; ++i) {\n    skinUrls.push(LOADER_BASE_URL\n        + '/skins/' + encodeURIComponent(skins[i]) + '.css');\n  }\n  skinUrls.push(LOADER_BASE_URL + '/prettify.css');\n  loadStylesheetsFallingBack(skinUrls);\n\n  var prettyPrint = (function () {\n    /**\n     * @license\n     * Copyright (C) 2006 Google Inc.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    \n    /**\n     * @fileoverview\n     * some functions for browser-side pretty printing of code contained in html.\n     *\n     * <p>\n     * For a fairly comprehensive set of languages see the\n     * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n     * file that came with this source.  At a minimum, the lexer should work on a\n     * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n     * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n     * and a subset of Perl, but, because of commenting conventions, doesn't work on\n     * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n     * <p>\n     * Usage: <ol>\n     * <li> include this source file in an html page via\n     *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n     * <li> define style rules.  See the example page for examples.\n     * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n     *    {@code class=prettyprint.}\n     *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n     *    printer needs to do more substantial DOM manipulations to support that, so\n     *    some css styles may not be preserved.\n     * </ol>\n     * That's it.  I wanted to keep the API as simple as possible, so there's no\n     * need to specify which language the code is in, but if you wish, you can add\n     * another class to the {@code <pre>} or {@code <code>} element to specify the\n     * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n     * starts with \"lang-\" followed by a file extension, specifies the file type.\n     * See the \"lang-*.js\" files in this directory for code that implements\n     * per-language file handlers.\n     * <p>\n     * Change log:<br>\n     * cbeust, 2006/08/22\n     * <blockquote>\n     *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n     * </blockquote>\n     * @requires console\n     */\n    \n    // JSLint declarations\n    /*global console, document, navigator, setTimeout, window, define */\n    \n    \n    var HACK_TO_FIX_JS_INCLUDE_PL;\n    \n    /**\n     * {@type !{\n     *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n     *   'registerLangHandler': function (function (JobT), Array.<string>),\n     *   'PR_ATTRIB_NAME': string,\n     *   'PR_ATTRIB_NAME': string,\n     *   'PR_ATTRIB_VALUE': string,\n     *   'PR_COMMENT': string,\n     *   'PR_DECLARATION': string,\n     *   'PR_KEYWORD': string,\n     *   'PR_LITERAL': string,\n     *   'PR_NOCODE': string,\n     *   'PR_PLAIN': string,\n     *   'PR_PUNCTUATION': string,\n     *   'PR_SOURCE': string,\n     *   'PR_STRING': string,\n     *   'PR_TAG': string,\n     *   'PR_TYPE': string,\n     *   'prettyPrintOne': function (string, string, number|boolean),\n     *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n     * }}\n     * @const\n     */\n    var PR;\n    \n    /**\n     * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n     * UI events.\n     * If set to {@code false}, {@code prettyPrint()} is synchronous.\n     */\n    window['PR_SHOULD_USE_CONTINUATION'] = true;\n    \n    /**\n     * Pretty print a chunk of code.\n     * @param {string} sourceCodeHtml The HTML to pretty print.\n     * @param {string} opt_langExtension The language name to use.\n     *     Typically, a filename extension like 'cpp' or 'java'.\n     * @param {number|boolean} opt_numberLines True to number lines,\n     *     or the 1-indexed number of the first line in sourceCodeHtml.\n     * @return {string} code as html, but prettier\n     */\n    var prettyPrintOne;\n    /**\n     * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n     * {@code class=prettyprint} and prettify them.\n     *\n     * @param {Function} opt_whenDone called when prettifying is done.\n     * @param {HTMLElement|HTMLDocument} opt_root an element or document\n     *   containing all the elements to pretty print.\n     *   Defaults to {@code document.body}.\n     */\n    var prettyPrint;\n    \n    \n    (function () {\n      var win = window;\n      // Keyword lists for various languages.\n      // We use things that coerce to strings to make them compact when minified\n      // and to defeat aggressive optimizers that fold large string constants.\n      var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n      var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n          \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n          \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n      var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n          \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n      var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n          \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n          \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n          \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n          \"static_cast,template,typeid,typename,using,virtual,where\"];\n      var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n          \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n          \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n          \"throws,transient\"];\n      var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n          \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n          \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n          \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n          \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n          \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n      var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n          \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n          \"throw,true,try,unless,until,when,while,yes\";\n      var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n          \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" +\n          \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" +\n          \"yield,Infinity,NaN\"];\n      var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n          \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n          \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n      var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n          \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n          \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n          \"False,True,None\"];\n      var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n          \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n          \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n          \"BEGIN,END\"];\n      var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n          \"function,in,local,set,then,until\"];\n      var ALL_KEYWORDS = [\n          CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n          PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n      var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n    \n      // token style names.  correspond to css classes\n      /**\n       * token style for a string literal\n       * @const\n       */\n      var PR_STRING = 'str';\n      /**\n       * token style for a keyword\n       * @const\n       */\n      var PR_KEYWORD = 'kwd';\n      /**\n       * token style for a comment\n       * @const\n       */\n      var PR_COMMENT = 'com';\n      /**\n       * token style for a type\n       * @const\n       */\n      var PR_TYPE = 'typ';\n      /**\n       * token style for a literal value.  e.g. 1, null, true.\n       * @const\n       */\n      var PR_LITERAL = 'lit';\n      /**\n       * token style for a punctuation string.\n       * @const\n       */\n      var PR_PUNCTUATION = 'pun';\n      /**\n       * token style for plain text.\n       * @const\n       */\n      var PR_PLAIN = 'pln';\n    \n      /**\n       * token style for an sgml tag.\n       * @const\n       */\n      var PR_TAG = 'tag';\n      /**\n       * token style for a markup declaration such as a DOCTYPE.\n       * @const\n       */\n      var PR_DECLARATION = 'dec';\n      /**\n       * token style for embedded source.\n       * @const\n       */\n      var PR_SOURCE = 'src';\n      /**\n       * token style for an sgml attribute name.\n       * @const\n       */\n      var PR_ATTRIB_NAME = 'atn';\n      /**\n       * token style for an sgml attribute value.\n       * @const\n       */\n      var PR_ATTRIB_VALUE = 'atv';\n    \n      /**\n       * A class that indicates a section of markup that is not code, e.g. to allow\n       * embedding of line numbers within code listings.\n       * @const\n       */\n      var PR_NOCODE = 'nocode';\n    \n      \n      \n      /**\n       * A set of tokens that can precede a regular expression literal in\n       * javascript\n       * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n       * has the full list, but I've removed ones that might be problematic when\n       * seen in languages that don't support regular expression literals.\n       *\n       * <p>Specifically, I've removed any keywords that can't precede a regexp\n       * literal in a syntactically legal javascript program, and I've removed the\n       * \"in\" keyword since it's not a keyword in many languages, and might be used\n       * as a count of inches.\n       *\n       * <p>The link above does not accurately describe EcmaScript rules since\n       * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n       * very well in practice.\n       *\n       * @private\n       * @const\n       */\n      var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n      \n      // CAVEAT: this does not properly handle the case where a regular\n      // expression immediately follows another since a regular expression may\n      // have flags for case-sensitivity and the like.  Having regexp tokens\n      // adjacent is not valid in any language I'm aware of, so I'm punting.\n      // TODO: maybe style special characters inside a regexp as punctuation.\n    \n      /**\n       * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n       * matches the union of the sets of strings matched by the input RegExp.\n       * Since it matches globally, if the input strings have a start-of-input\n       * anchor (/^.../), it is ignored for the purposes of unioning.\n       * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n       * @return {RegExp} a global regex.\n       */\n      function combinePrefixPatterns(regexs) {\n        var capturedGroupIndex = 0;\n      \n        var needToFoldCase = false;\n        var ignoreCase = false;\n        for (var i = 0, n = regexs.length; i < n; ++i) {\n          var regex = regexs[i];\n          if (regex.ignoreCase) {\n            ignoreCase = true;\n          } else if (/[a-z]/i.test(regex.source.replace(\n                         /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n            needToFoldCase = true;\n            ignoreCase = false;\n            break;\n          }\n        }\n      \n        var escapeCharToCodeUnit = {\n          'b': 8,\n          't': 9,\n          'n': 0xa,\n          'v': 0xb,\n          'f': 0xc,\n          'r': 0xd\n        };\n      \n        function decodeEscape(charsetPart) {\n          var cc0 = charsetPart.charCodeAt(0);\n          if (cc0 !== 92 /* \\\\ */) {\n            return cc0;\n          }\n          var c1 = charsetPart.charAt(1);\n          cc0 = escapeCharToCodeUnit[c1];\n          if (cc0) {\n            return cc0;\n          } else if ('0' <= c1 && c1 <= '7') {\n            return parseInt(charsetPart.substring(1), 8);\n          } else if (c1 === 'u' || c1 === 'x') {\n            return parseInt(charsetPart.substring(2), 16);\n          } else {\n            return charsetPart.charCodeAt(1);\n          }\n        }\n      \n        function encodeEscape(charCode) {\n          if (charCode < 0x20) {\n            return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n          }\n          var ch = String.fromCharCode(charCode);\n          return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n              ? \"\\\\\" + ch : ch;\n        }\n      \n        function caseFoldCharset(charSet) {\n          var charsetParts = charSet.substring(1, charSet.length - 1).match(\n              new RegExp(\n                  '\\\\\\\\u[0-9A-Fa-f]{4}'\n                  + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n                  + '|\\\\\\\\[0-3][0-7]{0,2}'\n                  + '|\\\\\\\\[0-7]{1,2}'\n                  + '|\\\\\\\\[\\\\s\\\\S]'\n                  + '|-'\n                  + '|[^-\\\\\\\\]',\n                  'g'));\n          var ranges = [];\n          var inverse = charsetParts[0] === '^';\n      \n          var out = ['['];\n          if (inverse) { out.push('^'); }\n      \n          for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n            var p = charsetParts[i];\n            if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n              out.push(p);\n            } else {\n              var start = decodeEscape(p);\n              var end;\n              if (i + 2 < n && '-' === charsetParts[i + 1]) {\n                end = decodeEscape(charsetParts[i + 2]);\n                i += 2;\n              } else {\n                end = start;\n              }\n              ranges.push([start, end]);\n              // If the range might intersect letters, then expand it.\n              // This case handling is too simplistic.\n              // It does not deal with non-latin case folding.\n              // It works for latin source code identifiers though.\n              if (!(end < 65 || start > 122)) {\n                if (!(end < 65 || start > 90)) {\n                  ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n                }\n                if (!(end < 97 || start > 122)) {\n                  ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n                }\n              }\n            }\n          }\n      \n          // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n          // -> [[1, 12], [14, 14], [16, 17]]\n          ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n          var consolidatedRanges = [];\n          var lastRange = [];\n          for (var i = 0; i < ranges.length; ++i) {\n            var range = ranges[i];\n            if (range[0] <= lastRange[1] + 1) {\n              lastRange[1] = Math.max(lastRange[1], range[1]);\n            } else {\n              consolidatedRanges.push(lastRange = range);\n            }\n          }\n      \n          for (var i = 0; i < consolidatedRanges.length; ++i) {\n            var range = consolidatedRanges[i];\n            out.push(encodeEscape(range[0]));\n            if (range[1] > range[0]) {\n              if (range[1] + 1 > range[0]) { out.push('-'); }\n              out.push(encodeEscape(range[1]));\n            }\n          }\n          out.push(']');\n          return out.join('');\n        }\n      \n        function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n          // Split into character sets, escape sequences, punctuation strings\n          // like ('(', '(?:', ')', '^'), and runs of characters that do not\n          // include any of the above.\n          var parts = regex.source.match(\n              new RegExp(\n                  '(?:'\n                  + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n                  + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n                  + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n                  + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n                  + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n                  + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n                  + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n                  + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n                  + ')',\n                  'g'));\n          var n = parts.length;\n      \n          // Maps captured group numbers to the number they will occupy in\n          // the output or to -1 if that has not been determined, or to\n          // undefined if they need not be capturing in the output.\n          var capturedGroups = [];\n      \n          // Walk over and identify back references to build the capturedGroups\n          // mapping.\n          for (var i = 0, groupIndex = 0; i < n; ++i) {\n            var p = parts[i];\n            if (p === '(') {\n              // groups are 1-indexed, so max group index is count of '('\n              ++groupIndex;\n            } else if ('\\\\' === p.charAt(0)) {\n              var decimalValue = +p.substring(1);\n              if (decimalValue) {\n                if (decimalValue <= groupIndex) {\n                  capturedGroups[decimalValue] = -1;\n                } else {\n                  // Replace with an unambiguous escape sequence so that\n                  // an octal escape sequence does not turn into a backreference\n                  // to a capturing group from an earlier regex.\n                  parts[i] = encodeEscape(decimalValue);\n                }\n              }\n            }\n          }\n      \n          // Renumber groups and reduce capturing groups to non-capturing groups\n          // where possible.\n          for (var i = 1; i < capturedGroups.length; ++i) {\n            if (-1 === capturedGroups[i]) {\n              capturedGroups[i] = ++capturedGroupIndex;\n            }\n          }\n          for (var i = 0, groupIndex = 0; i < n; ++i) {\n            var p = parts[i];\n            if (p === '(') {\n              ++groupIndex;\n              if (!capturedGroups[groupIndex]) {\n                parts[i] = '(?:';\n              }\n            } else if ('\\\\' === p.charAt(0)) {\n              var decimalValue = +p.substring(1);\n              if (decimalValue && decimalValue <= groupIndex) {\n                parts[i] = '\\\\' + capturedGroups[decimalValue];\n              }\n            }\n          }\n      \n          // Remove any prefix anchors so that the output will match anywhere.\n          // ^^ really does mean an anchored match though.\n          for (var i = 0; i < n; ++i) {\n            if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n          }\n      \n          // Expand letters to groups to handle mixing of case-sensitive and\n          // case-insensitive patterns if necessary.\n          if (regex.ignoreCase && needToFoldCase) {\n            for (var i = 0; i < n; ++i) {\n              var p = parts[i];\n              var ch0 = p.charAt(0);\n              if (p.length >= 2 && ch0 === '[') {\n                parts[i] = caseFoldCharset(p);\n              } else if (ch0 !== '\\\\') {\n                // TODO: handle letters in numeric escapes.\n                parts[i] = p.replace(\n                    /[a-zA-Z]/g,\n                    function (ch) {\n                      var cc = ch.charCodeAt(0);\n                      return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                    });\n              }\n            }\n          }\n      \n          return parts.join('');\n        }\n      \n        var rewritten = [];\n        for (var i = 0, n = regexs.length; i < n; ++i) {\n          var regex = regexs[i];\n          if (regex.global || regex.multiline) { throw new Error('' + regex); }\n          rewritten.push(\n              '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n        }\n      \n        return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n      }\n    \n      /**\n       * Split markup into a string of source code and an array mapping ranges in\n       * that string to the text nodes in which they appear.\n       *\n       * <p>\n       * The HTML DOM structure:</p>\n       * <pre>\n       * (Element   \"p\"\n       *   (Element \"b\"\n       *     (Text  \"print \"))       ; #1\n       *   (Text    \"'Hello '\")      ; #2\n       *   (Element \"br\")            ; #3\n       *   (Text    \"  + 'World';\")) ; #4\n       * </pre>\n       * <p>\n       * corresponds to the HTML\n       * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n       *\n       * <p>\n       * It will produce the output:</p>\n       * <pre>\n       * {\n       *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n       *   //                     1          2\n       *   //           012345678901234 5678901234567\n       *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n       * }\n       * </pre>\n       * <p>\n       * where #1 is a reference to the {@code \"print \"} text node above, and so\n       * on for the other text nodes.\n       * </p>\n       *\n       * <p>\n       * The {@code} spans array is an array of pairs.  Even elements are the start\n       * indices of substrings, and odd elements are the text nodes (or BR elements)\n       * that contain the text for those substrings.\n       * Substrings continue until the next index or the end of the source.\n       * </p>\n       *\n       * @param {Node} node an HTML DOM subtree containing source-code.\n       * @param {boolean|number} isPreformatted truthy if white-space in\n       *    text nodes should be considered significant.\n       * @return {SourceSpansT} source code and the nodes in which they occur.\n       */\n      function extractSourceSpans(node, isPreformatted) {\n        var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n      \n        var chunks = [];\n        var length = 0;\n        var spans = [];\n        var k = 0;\n      \n        function walk(node) {\n          var type = node.nodeType;\n          if (type == 1) {  // Element\n            if (nocode.test(node.className)) { return; }\n            for (var child = node.firstChild; child; child = child.nextSibling) {\n              walk(child);\n            }\n            var nodeName = node.nodeName.toLowerCase();\n            if ('br' === nodeName || 'li' === nodeName) {\n              chunks[k] = '\\n';\n              spans[k << 1] = length++;\n              spans[(k++ << 1) | 1] = node;\n            }\n          } else if (type == 3 || type == 4) {  // Text\n            var text = node.nodeValue;\n            if (text.length) {\n              if (!isPreformatted) {\n                text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n              } else {\n                text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n              }\n              // TODO: handle tabs here?\n              chunks[k] = text;\n              spans[k << 1] = length;\n              length += text.length;\n              spans[(k++ << 1) | 1] = node;\n            }\n          }\n        }\n      \n        walk(node);\n      \n        return {\n          sourceCode: chunks.join('').replace(/\\n$/, ''),\n          spans: spans\n        };\n      }\n    \n      /**\n       * Apply the given language handler to sourceCode and add the resulting\n       * decorations to out.\n       * @param {!Element} sourceNode\n       * @param {number} basePos the index of sourceCode within the chunk of source\n       *    whose decorations are already present on out.\n       * @param {string} sourceCode\n       * @param {function(JobT)} langHandler\n       * @param {DecorationsT} out\n       */\n      function appendDecorations(\n          sourceNode, basePos, sourceCode, langHandler, out) {\n        if (!sourceCode) { return; }\n        /** @type {JobT} */\n        var job = {\n          sourceNode: sourceNode,\n          pre: 1,\n          langExtension: null,\n          numberLines: null,\n          sourceCode: sourceCode,\n          spans: null,\n          basePos: basePos,\n          decorations: null\n        };\n        langHandler(job);\n        out.push.apply(out, job.decorations);\n      }\n    \n      var notWs = /\\S/;\n    \n      /**\n       * Given an element, if it contains only one child element and any text nodes\n       * it contains contain only space characters, return the sole child element.\n       * Otherwise returns undefined.\n       * <p>\n       * This is meant to return the CODE element in {@code <pre><code ...>} when\n       * there is a single child element that contains all the non-space textual\n       * content, but not to return anything where there are multiple child elements\n       * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n       * is textual content.\n       */\n      function childContentWrapper(element) {\n        var wrapper = undefined;\n        for (var c = element.firstChild; c; c = c.nextSibling) {\n          var type = c.nodeType;\n          wrapper = (type === 1)  // Element Node\n              ? (wrapper ? element : c)\n              : (type === 3)  // Text Node\n              ? (notWs.test(c.nodeValue) ? element : wrapper)\n              : wrapper;\n        }\n        return wrapper === element ? undefined : wrapper;\n      }\n    \n      /** Given triples of [style, pattern, context] returns a lexing function,\n        * The lexing function interprets the patterns to find token boundaries and\n        * returns a decoration list of the form\n        * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n        * where index_n is an index into the sourceCode, and style_n is a style\n        * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n        * all characters in sourceCode[index_n-1:index_n].\n        *\n        * The stylePatterns is a list whose elements have the form\n        * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n        *\n        * Style is a style constant like PR_PLAIN, or can be a string of the\n        * form 'lang-FOO', where FOO is a language extension describing the\n        * language of the portion of the token in $1 after pattern executes.\n        * E.g., if style is 'lang-lisp', and group 1 contains the text\n        * '(hello (world))', then that portion of the token will be passed to the\n        * registered lisp handler for formatting.\n        * The text before and after group 1 will be restyled using this decorator\n        * so decorators should take care that this doesn't result in infinite\n        * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n        * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n        * '<script>foo()<\\/script>', which would cause the current decorator to\n        * be called with '<script>' which would not match the same rule since\n        * group 1 must not be empty, so it would be instead styled as PR_TAG by\n        * the generic tag rule.  The handler registered for the 'js' extension would\n        * then be called with 'foo()', and finally, the current decorator would\n        * be called with '<\\/script>' which would not match the original rule and\n        * so the generic tag rule would identify it as a tag.\n        *\n        * Pattern must only match prefixes, and if it matches a prefix, then that\n        * match is considered a token with the same style.\n        *\n        * Context is applied to the last non-whitespace, non-comment token\n        * recognized.\n        *\n        * Shortcut is an optional string of characters, any of which, if the first\n        * character, gurantee that this pattern and only this pattern matches.\n        *\n        * @param {Array} shortcutStylePatterns patterns that always start with\n        *   a known character.  Must have a shortcut string.\n        * @param {Array} fallthroughStylePatterns patterns that will be tried in\n        *   order if the shortcut ones fail.  May have shortcuts.\n        *\n        * @return {function (JobT)} a function that takes an undecorated job and\n        *   attaches a list of decorations.\n        */\n      function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n        var shortcuts = {};\n        var tokenizer;\n        (function () {\n          var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n          var allRegexs = [];\n          var regexKeys = {};\n          for (var i = 0, n = allPatterns.length; i < n; ++i) {\n            var patternParts = allPatterns[i];\n            var shortcutChars = patternParts[3];\n            if (shortcutChars) {\n              for (var c = shortcutChars.length; --c >= 0;) {\n                shortcuts[shortcutChars.charAt(c)] = patternParts;\n              }\n            }\n            var regex = patternParts[1];\n            var k = '' + regex;\n            if (!regexKeys.hasOwnProperty(k)) {\n              allRegexs.push(regex);\n              regexKeys[k] = null;\n            }\n          }\n          allRegexs.push(/[\\0-\\uffff]/);\n          tokenizer = combinePrefixPatterns(allRegexs);\n        })();\n    \n        var nPatterns = fallthroughStylePatterns.length;\n    \n        /**\n         * Lexes job.sourceCode and attaches an output array job.decorations of\n         * style classes preceded by the position at which they start in\n         * job.sourceCode in order.\n         *\n         * @type{function (JobT)}\n         */\n        var decorate = function (job) {\n          var sourceCode = job.sourceCode, basePos = job.basePos;\n          var sourceNode = job.sourceNode;\n          /** Even entries are positions in source in ascending order.  Odd enties\n            * are style markers (e.g., PR_COMMENT) that run from that position until\n            * the end.\n            * @type {DecorationsT}\n            */\n          var decorations = [basePos, PR_PLAIN];\n          var pos = 0;  // index into sourceCode\n          var tokens = sourceCode.match(tokenizer) || [];\n          var styleCache = {};\n    \n          for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n            var token = tokens[ti];\n            var style = styleCache[token];\n            var match = void 0;\n    \n            var isEmbedded;\n            if (typeof style === 'string') {\n              isEmbedded = false;\n            } else {\n              var patternParts = shortcuts[token.charAt(0)];\n              if (patternParts) {\n                match = token.match(patternParts[1]);\n                style = patternParts[0];\n              } else {\n                for (var i = 0; i < nPatterns; ++i) {\n                  patternParts = fallthroughStylePatterns[i];\n                  match = token.match(patternParts[1]);\n                  if (match) {\n                    style = patternParts[0];\n                    break;\n                  }\n                }\n    \n                if (!match) {  // make sure that we make progress\n                  style = PR_PLAIN;\n                }\n              }\n    \n              isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n              if (isEmbedded && !(match && typeof match[1] === 'string')) {\n                isEmbedded = false;\n                style = PR_SOURCE;\n              }\n    \n              if (!isEmbedded) { styleCache[token] = style; }\n            }\n    \n            var tokenStart = pos;\n            pos += token.length;\n    \n            if (!isEmbedded) {\n              decorations.push(basePos + tokenStart, style);\n            } else {  // Treat group 1 as an embedded block of source code.\n              var embeddedSource = match[1];\n              var embeddedSourceStart = token.indexOf(embeddedSource);\n              var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n              if (match[2]) {\n                // If embeddedSource can be blank, then it would match at the\n                // beginning which would cause us to infinitely recurse on the\n                // entire token, so we catch the right context in match[2].\n                embeddedSourceEnd = token.length - match[2].length;\n                embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n              }\n              var lang = style.substring(5);\n              // Decorate the left of the embedded source\n              appendDecorations(\n                  sourceNode,\n                  basePos + tokenStart,\n                  token.substring(0, embeddedSourceStart),\n                  decorate, decorations);\n              // Decorate the embedded source\n              appendDecorations(\n                  sourceNode,\n                  basePos + tokenStart + embeddedSourceStart,\n                  embeddedSource,\n                  langHandlerForExtension(lang, embeddedSource),\n                  decorations);\n              // Decorate the right of the embedded section\n              appendDecorations(\n                  sourceNode,\n                  basePos + tokenStart + embeddedSourceEnd,\n                  token.substring(embeddedSourceEnd),\n                  decorate, decorations);\n            }\n          }\n          job.decorations = decorations;\n        };\n        return decorate;\n      }\n    \n      /** returns a function that produces a list of decorations from source text.\n        *\n        * This code treats \", ', and ` as string delimiters, and \\ as a string\n        * escape.  It does not recognize perl's qq() style strings.\n        * It has no special handling for double delimiter escapes as in basic, or\n        * the tripled delimiters used in python, but should work on those regardless\n        * although in those cases a single string literal may be broken up into\n        * multiple adjacent string literals.\n        *\n        * It recognizes C, C++, and shell style comments.\n        *\n        * @param {Object} options a set of optional parameters.\n        * @return {function (JobT)} a function that examines the source code\n        *     in the input job and builds a decoration list which it attaches to\n        *     the job.\n        */\n      function sourceDecorator(options) {\n        var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n        if (options['tripleQuotedStrings']) {\n          // '''multi-line-string''', 'single-line-string', and double-quoted\n          shortcutStylePatterns.push(\n              [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n               null, '\\'\"']);\n        } else if (options['multiLineStrings']) {\n          // 'multi-line-string', \"multi-line-string\"\n          shortcutStylePatterns.push(\n              [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n               null, '\\'\"`']);\n        } else {\n          // 'single-line-string', \"single-line-string\"\n          shortcutStylePatterns.push(\n              [PR_STRING,\n               /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n               null, '\"\\'']);\n        }\n        if (options['verbatimStrings']) {\n          // verbatim-string-literal production from the C# grammar.  See issue 93.\n          fallthroughStylePatterns.push(\n              [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n        }\n        var hc = options['hashComments'];\n        if (hc) {\n          if (options['cStyleComments']) {\n            if (hc > 1) {  // multiline hash comments\n              shortcutStylePatterns.push(\n                  [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n            } else {\n              // Stop C preprocessor declarations at an unclosed open comment\n              shortcutStylePatterns.push(\n                  [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n                   null, '#']);\n            }\n            // #include <stdio.h>\n            fallthroughStylePatterns.push(\n                [PR_STRING,\n                 /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n                 null]);\n          } else {\n            shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n          }\n        }\n        if (options['cStyleComments']) {\n          fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n          fallthroughStylePatterns.push(\n              [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n        }\n        var regexLiterals = options['regexLiterals'];\n        if (regexLiterals) {\n          /**\n           * @const\n           */\n          var regexExcls = regexLiterals > 1\n            ? ''  // Multiline regex literals\n            : '\\n\\r';\n          /**\n           * @const\n           */\n          var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n          /**\n           * @const\n           */\n          var REGEX_LITERAL = (\n              // A regular expression literal starts with a slash that is\n              // not followed by * or / so that it is not confused with\n              // comments.\n              '/(?=[^/*' + regexExcls + '])'\n              // and then contains any number of raw characters,\n              + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n              // escape sequences (\\x5C),\n              +    '|\\\\x5C' + regexAny\n              // or non-nesting character sets (\\x5B\\x5D);\n              +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n              +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n              // finally closed by a /.\n              + '/');\n          fallthroughStylePatterns.push(\n              ['lang-regex',\n               RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n               ]);\n        }\n    \n        var types = options['types'];\n        if (types) {\n          fallthroughStylePatterns.push([PR_TYPE, types]);\n        }\n    \n        var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n        if (keywords.length) {\n          fallthroughStylePatterns.push(\n              [PR_KEYWORD,\n               new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n               null]);\n        }\n    \n        shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n    \n        var punctuation =\n          // The Bash man page says\n    \n          // A word is a sequence of characters considered as a single\n          // unit by GRUB. Words are separated by metacharacters,\n          // which are the following plus space, tab, and newline: { }\n          // | & $ ; < >\n          // ...\n    \n          // A word beginning with # causes that word and all remaining\n          // characters on that line to be ignored.\n    \n          // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n          // comment but empirically\n          // $ echo {#}\n          // {#}\n          // $ echo \\$#\n          // $#\n          // $ echo }#\n          // }#\n    \n          // so /(?:^|[|&;<>\\s])/ is more appropriate.\n    \n          // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n          // suggests that this definition is compatible with a\n          // default mode that tries to use a single token definition\n          // to recognize both bash/python style comments and C\n          // preprocessor directives.\n    \n          // This definition of punctuation does not include # in the list of\n          // follow-on exclusions, so # will not be broken before if preceeded\n          // by a punctuation character.  We could try to exclude # after\n          // [|&;<>] but that doesn't seem to cause many major problems.\n          // If that does turn out to be a problem, we should change the below\n          // when hc is truthy to include # in the run of punctuation characters\n          // only when not followint [|&;<>].\n          '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n        if (options['regexLiterals']) {\n          punctuation += '(?!\\s*\\/)';\n        }\n    \n        fallthroughStylePatterns.push(\n            // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n            [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n            [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n            [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n            [PR_LITERAL,\n             new RegExp(\n                 '^(?:'\n                 // A hex number\n                 + '0x[a-f0-9]+'\n                 // or an octal or decimal number,\n                 + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n                 // possibly in scientific notation\n                 + '(?:e[+\\\\-]?\\\\d+)?'\n                 + ')'\n                 // with an optional modifier like UL for unsigned long\n                 + '[a-z]*', 'i'),\n             null, '0123456789'],\n            // Don't treat escaped quotes in bash as starting strings.\n            // See issue 144.\n            [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n            [PR_PUNCTUATION, new RegExp(punctuation), null]);\n    \n        return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n      }\n    \n      var decorateSource = sourceDecorator({\n            'keywords': ALL_KEYWORDS,\n            'hashComments': true,\n            'cStyleComments': true,\n            'multiLineStrings': true,\n            'regexLiterals': true\n          });\n    \n      /**\n       * Given a DOM subtree, wraps it in a list, and puts each line into its own\n       * list item.\n       *\n       * @param {Node} node modified in place.  Its content is pulled into an\n       *     HTMLOListElement, and each line is moved into a separate list item.\n       *     This requires cloning elements, so the input might not have unique\n       *     IDs after numbering.\n       * @param {number|null|boolean} startLineNum\n       *     If truthy, coerced to an integer which is the 1-indexed line number\n       *     of the first line of code.  The number of the first line will be\n       *     attached to the list.\n       * @param {boolean} isPreformatted true iff white-space in text nodes should\n       *     be treated as significant.\n       */\n      function numberLines(node, startLineNum, isPreformatted) {\n        var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n        var lineBreak = /\\r\\n?|\\n/;\n      \n        var document = node.ownerDocument;\n      \n        var li = document.createElement('li');\n        while (node.firstChild) {\n          li.appendChild(node.firstChild);\n        }\n        // An array of lines.  We split below, so this is initialized to one\n        // un-split line.\n        var listItems = [li];\n      \n        function walk(node) {\n          var type = node.nodeType;\n          if (type == 1 && !nocode.test(node.className)) {  // Element\n            if ('br' === node.nodeName) {\n              breakAfter(node);\n              // Discard the <BR> since it is now flush against a </LI>.\n              if (node.parentNode) {\n                node.parentNode.removeChild(node);\n              }\n            } else {\n              for (var child = node.firstChild; child; child = child.nextSibling) {\n                walk(child);\n              }\n            }\n          } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n            var text = node.nodeValue;\n            var match = text.match(lineBreak);\n            if (match) {\n              var firstLine = text.substring(0, match.index);\n              node.nodeValue = firstLine;\n              var tail = text.substring(match.index + match[0].length);\n              if (tail) {\n                var parent = node.parentNode;\n                parent.insertBefore(\n                  document.createTextNode(tail), node.nextSibling);\n              }\n              breakAfter(node);\n              if (!firstLine) {\n                // Don't leave blank text nodes in the DOM.\n                node.parentNode.removeChild(node);\n              }\n            }\n          }\n        }\n      \n        // Split a line after the given node.\n        function breakAfter(lineEndNode) {\n          // If there's nothing to the right, then we can skip ending the line\n          // here, and move root-wards since splitting just before an end-tag\n          // would require us to create a bunch of empty copies.\n          while (!lineEndNode.nextSibling) {\n            lineEndNode = lineEndNode.parentNode;\n            if (!lineEndNode) { return; }\n          }\n      \n          function breakLeftOf(limit, copy) {\n            // Clone shallowly if this node needs to be on both sides of the break.\n            var rightSide = copy ? limit.cloneNode(false) : limit;\n            var parent = limit.parentNode;\n            if (parent) {\n              // We clone the parent chain.\n              // This helps us resurrect important styling elements that cross lines.\n              // E.g. in <i>Foo<br>Bar</i>\n              // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n              var parentClone = breakLeftOf(parent, 1);\n              // Move the clone and everything to the right of the original\n              // onto the cloned parent.\n              var next = limit.nextSibling;\n              parentClone.appendChild(rightSide);\n              for (var sibling = next; sibling; sibling = next) {\n                next = sibling.nextSibling;\n                parentClone.appendChild(sibling);\n              }\n            }\n            return rightSide;\n          }\n      \n          var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n      \n          // Walk the parent chain until we reach an unattached LI.\n          for (var parent;\n               // Check nodeType since IE invents document fragments.\n               (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n            copiedListItem = parent;\n          }\n          // Put it on the list of lines for later processing.\n          listItems.push(copiedListItem);\n        }\n      \n        // Split lines while there are lines left to split.\n        for (var i = 0;  // Number of lines that have been split so far.\n             i < listItems.length;  // length updated by breakAfter calls.\n             ++i) {\n          walk(listItems[i]);\n        }\n      \n        // Make sure numeric indices show correctly.\n        if (startLineNum === (startLineNum|0)) {\n          listItems[0].setAttribute('value', startLineNum);\n        }\n      \n        var ol = document.createElement('ol');\n        ol.className = 'linenums';\n        var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n        for (var i = 0, n = listItems.length; i < n; ++i) {\n          li = listItems[i];\n          // Stick a class on the LIs so that stylesheets can\n          // color odd/even rows, or any other row pattern that\n          // is co-prime with 10.\n          li.className = 'L' + ((i + offset) % 10);\n          if (!li.firstChild) {\n            li.appendChild(document.createTextNode('\\xA0'));\n          }\n          ol.appendChild(li);\n        }\n      \n        node.appendChild(ol);\n      }\n    \n      /**\n       * Breaks {@code job.sourceCode} around style boundaries in\n       * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n       * @param {JobT} job\n       * @private\n       */\n      function recombineTagsAndDecorations(job) {\n        var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n        isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n        var newlineRe = /\\n/g;\n      \n        var source = job.sourceCode;\n        var sourceLength = source.length;\n        // Index into source after the last code-unit recombined.\n        var sourceIndex = 0;\n      \n        var spans = job.spans;\n        var nSpans = spans.length;\n        // Index into spans after the last span which ends at or before sourceIndex.\n        var spanIndex = 0;\n      \n        var decorations = job.decorations;\n        var nDecorations = decorations.length;\n        // Index into decorations after the last decoration which ends at or before\n        // sourceIndex.\n        var decorationIndex = 0;\n      \n        // Remove all zero-length decorations.\n        decorations[nDecorations] = sourceLength;\n        var decPos, i;\n        for (i = decPos = 0; i < nDecorations;) {\n          if (decorations[i] !== decorations[i + 2]) {\n            decorations[decPos++] = decorations[i++];\n            decorations[decPos++] = decorations[i++];\n          } else {\n            i += 2;\n          }\n        }\n        nDecorations = decPos;\n      \n        // Simplify decorations.\n        for (i = decPos = 0; i < nDecorations;) {\n          var startPos = decorations[i];\n          // Conflate all adjacent decorations that use the same style.\n          var startDec = decorations[i + 1];\n          var end = i + 2;\n          while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n            end += 2;\n          }\n          decorations[decPos++] = startPos;\n          decorations[decPos++] = startDec;\n          i = end;\n        }\n      \n        nDecorations = decorations.length = decPos;\n      \n        var sourceNode = job.sourceNode;\n        var oldDisplay = \"\";\n        if (sourceNode) {\n          oldDisplay = sourceNode.style.display;\n          sourceNode.style.display = 'none';\n        }\n        try {\n          var decoration = null;\n          while (spanIndex < nSpans) {\n            var spanStart = spans[spanIndex];\n            var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n                || sourceLength;\n      \n            var decEnd = decorations[decorationIndex + 2] || sourceLength;\n      \n            var end = Math.min(spanEnd, decEnd);\n      \n            var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n            var styledText;\n            if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n                // Don't introduce spans around empty text nodes.\n                && (styledText = source.substring(sourceIndex, end))) {\n              // This may seem bizarre, and it is.  Emitting LF on IE causes the\n              // code to display with spaces instead of line breaks.\n              // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n              // space to appear at the beginning of every line but the first.\n              // Emitting an old Mac OS 9 line separator makes everything spiffy.\n              if (isIE8OrEarlier) {\n                styledText = styledText.replace(newlineRe, '\\r');\n              }\n              textNode.nodeValue = styledText;\n              var document = textNode.ownerDocument;\n              var span = document.createElement('span');\n              span.className = decorations[decorationIndex + 1];\n              var parentNode = textNode.parentNode;\n              parentNode.replaceChild(span, textNode);\n              span.appendChild(textNode);\n              if (sourceIndex < spanEnd) {  // Split off a text node.\n                spans[spanIndex + 1] = textNode\n                    // TODO: Possibly optimize by using '' if there's no flicker.\n                    = document.createTextNode(source.substring(end, spanEnd));\n                parentNode.insertBefore(textNode, span.nextSibling);\n              }\n            }\n      \n            sourceIndex = end;\n      \n            if (sourceIndex >= spanEnd) {\n              spanIndex += 2;\n            }\n            if (sourceIndex >= decEnd) {\n              decorationIndex += 2;\n            }\n          }\n        } finally {\n          if (sourceNode) {\n            sourceNode.style.display = oldDisplay;\n          }\n        }\n      }\n    \n      /** Maps language-specific file extensions to handlers. */\n      var langHandlerRegistry = {};\n      /** Register a language handler for the given file extensions.\n        * @param {function (JobT)} handler a function from source code to a list\n        *      of decorations.  Takes a single argument job which describes the\n        *      state of the computation and attaches the decorations to it.\n        * @param {Array.<string>} fileExtensions\n        */\n      function registerLangHandler(handler, fileExtensions) {\n        for (var i = fileExtensions.length; --i >= 0;) {\n          var ext = fileExtensions[i];\n          if (!langHandlerRegistry.hasOwnProperty(ext)) {\n            langHandlerRegistry[ext] = handler;\n          } else if (win['console']) {\n            console['warn']('cannot override language handler %s', ext);\n          }\n        }\n      }\n      function langHandlerForExtension(extension, source) {\n        if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n          // Treat it as markup if the first non whitespace character is a < and\n          // the last non-whitespace character is a >.\n          extension = /^\\s*</.test(source)\n              ? 'default-markup'\n              : 'default-code';\n        }\n        return langHandlerRegistry[extension];\n      }\n      registerLangHandler(decorateSource, ['default-code']);\n      registerLangHandler(\n          createSimpleLexer(\n              [],\n              [\n               [PR_PLAIN,       /^[^<?]+/],\n               [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n               [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n               // Unescaped content in an unknown language\n               ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n               ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n               [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n               ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n               // Unescaped content in javascript.  (Or possibly vbscript).\n               ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n               // Contains unescaped stylesheet content\n               ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n               ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n              ]),\n          ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n      registerLangHandler(\n          createSimpleLexer(\n              [\n               [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n               [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n               ],\n              [\n               [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n               [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n               ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n               [PR_PUNCTUATION,  /^[=<>\\/]+/],\n               ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n               ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n               ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n               ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n               ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n               ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n               ]),\n          ['in.tag']);\n      registerLangHandler(\n          createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n      registerLangHandler(sourceDecorator({\n              'keywords': CPP_KEYWORDS,\n              'hashComments': true,\n              'cStyleComments': true,\n              'types': C_TYPES\n            }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n      registerLangHandler(sourceDecorator({\n              'keywords': 'null,true,false'\n            }), ['json']);\n      registerLangHandler(sourceDecorator({\n              'keywords': CSHARP_KEYWORDS,\n              'hashComments': true,\n              'cStyleComments': true,\n              'verbatimStrings': true,\n              'types': C_TYPES\n            }), ['cs']);\n      registerLangHandler(sourceDecorator({\n              'keywords': JAVA_KEYWORDS,\n              'cStyleComments': true\n            }), ['java']);\n      registerLangHandler(sourceDecorator({\n              'keywords': SH_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true\n            }), ['bash', 'bsh', 'csh', 'sh']);\n      registerLangHandler(sourceDecorator({\n              'keywords': PYTHON_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true,\n              'tripleQuotedStrings': true\n            }), ['cv', 'py', 'python']);\n      registerLangHandler(sourceDecorator({\n              'keywords': PERL_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true,\n              'regexLiterals': 2  // multiline regex literals\n            }), ['perl', 'pl', 'pm']);\n      registerLangHandler(sourceDecorator({\n              'keywords': RUBY_KEYWORDS,\n              'hashComments': true,\n              'multiLineStrings': true,\n              'regexLiterals': true\n            }), ['rb', 'ruby']);\n      registerLangHandler(sourceDecorator({\n              'keywords': JSCRIPT_KEYWORDS,\n              'cStyleComments': true,\n              'regexLiterals': true\n            }), ['javascript', 'js', 'ts', 'typescript']);\n      registerLangHandler(sourceDecorator({\n              'keywords': COFFEE_KEYWORDS,\n              'hashComments': 3,  // ### style block comments\n              'cStyleComments': true,\n              'multilineStrings': true,\n              'tripleQuotedStrings': true,\n              'regexLiterals': true\n            }), ['coffee']);\n      registerLangHandler(\n          createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n    \n      /** @param {JobT} job */\n      function applyDecorator(job) {\n        var opt_langExtension = job.langExtension;\n    \n        try {\n          // Extract tags, and convert the source code to plain text.\n          var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n          /** Plain text. @type {string} */\n          var source = sourceAndSpans.sourceCode;\n          job.sourceCode = source;\n          job.spans = sourceAndSpans.spans;\n          job.basePos = 0;\n    \n          // Apply the appropriate language handler\n          langHandlerForExtension(opt_langExtension, source)(job);\n    \n          // Integrate the decorations and tags back into the source code,\n          // modifying the sourceNode in place.\n          recombineTagsAndDecorations(job);\n        } catch (e) {\n          if (win['console']) {\n            console['log'](e && e['stack'] || e);\n          }\n        }\n      }\n    \n      /**\n       * Pretty print a chunk of code.\n       * @param sourceCodeHtml {string} The HTML to pretty print.\n       * @param opt_langExtension {string} The language name to use.\n       *     Typically, a filename extension like 'cpp' or 'java'.\n       * @param opt_numberLines {number|boolean} True to number lines,\n       *     or the 1-indexed number of the first line in sourceCodeHtml.\n       */\n      function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n        /** @type{number|boolean} */\n        var nl = opt_numberLines || false;\n        /** @type{string|null} */\n        var langExtension = opt_langExtension || null;\n        /** @type{!Element} */\n        var container = document.createElement('div');\n        // This could cause images to load and onload listeners to fire.\n        // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n        // We assume that the inner HTML is from a trusted source.\n        // The pre-tag is required for IE8 which strips newlines from innerHTML\n        // when it is injected into a <pre> tag.\n        // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n        // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n        container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n        container = /** @type{!Element} */(container.firstChild);\n        if (nl) {\n          numberLines(container, nl, true);\n        }\n    \n        /** @type{JobT} */\n        var job = {\n          langExtension: langExtension,\n          numberLines: nl,\n          sourceNode: container,\n          pre: 1,\n          sourceCode: null,\n          basePos: null,\n          spans: null,\n          decorations: null\n        };\n        applyDecorator(job);\n        return container.innerHTML;\n      }\n    \n       /**\n        * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n        * {@code class=prettyprint} and prettify them.\n        *\n        * @param {Function} opt_whenDone called when prettifying is done.\n        * @param {HTMLElement|HTMLDocument} opt_root an element or document\n        *   containing all the elements to pretty print.\n        *   Defaults to {@code document.body}.\n        */\n      function $prettyPrint(opt_whenDone, opt_root) {\n        var root = opt_root || document.body;\n        var doc = root.ownerDocument || document;\n        function byTagName(tn) { return root.getElementsByTagName(tn); }\n        // fetch a list of nodes to rewrite\n        var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n        var elements = [];\n        for (var i = 0; i < codeSegments.length; ++i) {\n          for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n            elements.push(codeSegments[i][j]);\n          }\n        }\n        codeSegments = null;\n    \n        var clock = Date;\n        if (!clock['now']) {\n          clock = { 'now': function () { return +(new Date); } };\n        }\n    \n        // The loop is broken into a series of continuations to make sure that we\n        // don't make the browser unresponsive when rewriting a large page.\n        var k = 0;\n    \n        var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n        var prettyPrintRe = /\\bprettyprint\\b/;\n        var prettyPrintedRe = /\\bprettyprinted\\b/;\n        var preformattedTagNameRe = /pre|xmp/i;\n        var codeRe = /^code$/i;\n        var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n        var EMPTY = {};\n    \n        function doWork() {\n          var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                         clock['now']() + 250 /* ms */ :\n                         Infinity);\n          for (; k < elements.length && clock['now']() < endTime; k++) {\n            var cs = elements[k];\n    \n            // Look for a preceding comment like\n            // <?prettify lang=\"...\" linenums=\"...\"?>\n            var attrs = EMPTY;\n            {\n              for (var preceder = cs; (preceder = preceder.previousSibling);) {\n                var nt = preceder.nodeType;\n                // <?foo?> is parsed by HTML 5 to a comment node (8)\n                // like <!--?foo?-->, but in XML is a processing instruction\n                var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n                if (value\n                    ? !/^\\??prettify\\b/.test(value)\n                    : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n                  // Skip over white-space text nodes but not others.\n                  break;\n                }\n                if (value) {\n                  attrs = {};\n                  value.replace(\n                      /\\b(\\w+)=([\\w:.%+-]+)/g,\n                    function (_, name, value) { attrs[name] = value; });\n                  break;\n                }\n              }\n            }\n    \n            var className = cs.className;\n            if ((attrs !== EMPTY || prettyPrintRe.test(className))\n                // Don't redo this if we've already done it.\n                // This allows recalling pretty print to just prettyprint elements\n                // that have been added to the page since last call.\n                && !prettyPrintedRe.test(className)) {\n    \n              // make sure this is not nested in an already prettified element\n              var nested = false;\n              for (var p = cs.parentNode; p; p = p.parentNode) {\n                var tn = p.tagName;\n                if (preCodeXmpRe.test(tn)\n                    && p.className && prettyPrintRe.test(p.className)) {\n                  nested = true;\n                  break;\n                }\n              }\n              if (!nested) {\n                // Mark done.  If we fail to prettyprint for whatever reason,\n                // we shouldn't try again.\n                cs.className += ' prettyprinted';\n    \n                // If the classes includes a language extensions, use it.\n                // Language extensions can be specified like\n                //     <pre class=\"prettyprint lang-cpp\">\n                // the language extension \"cpp\" is used to find a language handler\n                // as passed to PR.registerLangHandler.\n                // HTML5 recommends that a language be specified using \"language-\"\n                // as the prefix instead.  Google Code Prettify supports both.\n                // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n                var langExtension = attrs['lang'];\n                if (!langExtension) {\n                  langExtension = className.match(langExtensionRe);\n                  // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n                  var wrapper;\n                  if (!langExtension && (wrapper = childContentWrapper(cs))\n                      && codeRe.test(wrapper.tagName)) {\n                    langExtension = wrapper.className.match(langExtensionRe);\n                  }\n    \n                  if (langExtension) { langExtension = langExtension[1]; }\n                }\n    \n                var preformatted;\n                if (preformattedTagNameRe.test(cs.tagName)) {\n                  preformatted = 1;\n                } else {\n                  var currentStyle = cs['currentStyle'];\n                  var defaultView = doc.defaultView;\n                  var whitespace = (\n                      currentStyle\n                      ? currentStyle['whiteSpace']\n                      : (defaultView\n                         && defaultView.getComputedStyle)\n                      ? defaultView.getComputedStyle(cs, null)\n                      .getPropertyValue('white-space')\n                      : 0);\n                  preformatted = whitespace\n                      && 'pre' === whitespace.substring(0, 3);\n                }\n    \n                // Look for a class like linenums or linenums:<n> where <n> is the\n                // 1-indexed number of the first line.\n                var lineNums = attrs['linenums'];\n                if (!(lineNums = lineNums === 'true' || +lineNums)) {\n                  lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n                  lineNums =\n                    lineNums\n                    ? lineNums[1] && lineNums[1].length\n                      ? +lineNums[1] : true\n                    : false;\n                }\n                if (lineNums) { numberLines(cs, lineNums, preformatted); }\n    \n                // do the pretty printing\n                var prettyPrintingJob = {\n                  langExtension: langExtension,\n                  sourceNode: cs,\n                  numberLines: lineNums,\n                  pre: preformatted,\n                  sourceCode: null,\n                  basePos: null,\n                  spans: null,\n                  decorations: null\n                };\n                applyDecorator(prettyPrintingJob);\n              }\n            }\n          }\n          if (k < elements.length) {\n            // finish up in a continuation\n            win.setTimeout(doWork, 250);\n          } else if ('function' === typeof opt_whenDone) {\n            opt_whenDone();\n          }\n        }\n    \n        doWork();\n      }\n    \n      /**\n       * Contains functions for creating and registering new language handlers.\n       * @type {Object}\n       */\n      var PR = win['PR'] = {\n            'createSimpleLexer': createSimpleLexer,\n            'registerLangHandler': registerLangHandler,\n            'sourceDecorator': sourceDecorator,\n            'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n            'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n            'PR_COMMENT': PR_COMMENT,\n            'PR_DECLARATION': PR_DECLARATION,\n            'PR_KEYWORD': PR_KEYWORD,\n            'PR_LITERAL': PR_LITERAL,\n            'PR_NOCODE': PR_NOCODE,\n            'PR_PLAIN': PR_PLAIN,\n            'PR_PUNCTUATION': PR_PUNCTUATION,\n            'PR_SOURCE': PR_SOURCE,\n            'PR_STRING': PR_STRING,\n            'PR_TAG': PR_TAG,\n            'PR_TYPE': PR_TYPE,\n            'prettyPrintOne':\n               IN_GLOBAL_SCOPE\n                 ? (win['prettyPrintOne'] = $prettyPrintOne)\n                 : (prettyPrintOne = $prettyPrintOne),\n            'prettyPrint': prettyPrint =\n               IN_GLOBAL_SCOPE\n                 ? (win['prettyPrint'] = $prettyPrint)\n                 : (prettyPrint = $prettyPrint)\n          };\n    \n      // Make PR available via the Asynchronous Module Definition (AMD) API.\n      // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n      // The Asynchronous Module Definition (AMD) API specifies a\n      // mechanism for defining modules such that the module and its\n      // dependencies can be asynchronously loaded.\n      // ...\n      // To allow a clear indicator that a global define function (as\n      // needed for script src browser loading) conforms to the AMD API,\n      // any global define function SHOULD have a property called \"amd\"\n      // whose value is an object. This helps avoid conflict with any\n      // other existing JavaScript code that could have defined a define()\n      // function that does not conform to the AMD API.\n      var define = win['define'];\n      if (typeof define === \"function\" && define['amd']) {\n        define(\"google-code-prettify\", [], function () {\n          return PR;\n        });\n      }\n    })();\n    return prettyPrint;\n  })();\n\n  // If this script is deferred or async and the document is already\n  // loaded we need to wait for language handlers to load before performing\n  // any autorun.\n  function onLangsLoaded() {\n    if (autorun) {\n      contentLoaded(\n        function () {\n          var n = callbacks.length;\n          var callback = n ? function () {\n            for (var i = 0; i < n; ++i) {\n              (function (i) {\n                win.setTimeout(\n                   function () {\n                     win['exports'][callbacks[i]].apply(win, arguments);\n                   }, 0);\n               })(i);\n            }\n          } : void 0;\n          prettyPrint(callback);\n        });\n    }\n  }\n  checkPendingLanguages();\n\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/code-prettify/src/run_prettify.js\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}